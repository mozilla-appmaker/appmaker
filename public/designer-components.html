<polymer-element name="ceci-app" attributes="name appid remixedfrom appdescription apptags">
  <template>
    <link rel="stylesheet" href="/stylesheets/app.css"></link>
    <content></content>
  </template>

  <script>
    (function(global){
      // This returns a Version 4 (random) UUID
      // See: https://en.wikipedia.org/wiki/Universally_unique_identifier for more info

      function hex(length){
        if (length > 8) return hex(8) + hex(length-8); // routine is good for up to 8 digits
        var myHex = Math.random().toString(16).slice(2,2+length);
        return pad(myHex, length); // just in case we don't get 8 digits for some reason
      }

      function pad(str, length){
        while(str.length < length){
          str += '0';
        }
        return str;
      }

      function variant(){
          return '89ab'[Math.floor(Math.random() * 4)];
      }

      // Public interface
      function uuid(){
        return hex(8) + '-' + hex(4) + '-4' + hex(3) + '-' + variant() + hex(3) + '-' + hex(12);
      }
      global.uuid = uuid;

    })(this);
  </script>

  <script>
    function initCeciApp() {
      Polymer('ceci-app', {
        created: function() {
          window.dispatchEvent(new CustomEvent("CeciAppCreated", { detail: { source: this }} ));
        },
        ready: function() {
          if (this.querySelector('ceci-card')) {
            if (!this.querySelector('ceci-card[visible]')) {
              this.querySelector('ceci-card').setAttribute('visible', true);
            }
          }
          else {
            this.addCard();
          }
          if (!this.querySelector('ceci-collections')) {
            this.appendChild(document.createElement('ceci-collections'));
          }

          var audioContext = window.AudioContext || window.webkitAudioContext;
          if(audioContext) {
            if(!window.audioContext) {
              window.audioContext = new audioContext();
            }
            this.Audiocontext = window.audioContext;
          }

          window.dispatchEvent(new CustomEvent("CeciAppReady", { detail: { app:this }}));
        },
        attached: function() {
          window.dispatchEvent(new CustomEvent("CeciAppAttached"));
        },
        domReady: function() {
          var loadingPane = document.querySelector(".loading-pane");
          if (loadingPane) {
            loadingPane.classList.add("fade");
          }
          this.classList.add("loaded");
          window.dispatchEvent(new CustomEvent("CeciAppDOMReady", {detail: this}));
        },
        addCard: function() {
          var newCard = document.createElement('ceci-card');
          this.appendChild(newCard);
          newCard.show();
          this.dispatchEvent(new CustomEvent('cardAdded', {bubbles: true, detail: newCard}));
          newCard.show();
        },
        removeCard: function(index) {
          var cards = this.querySelectorAll('ceci-card');
          var card = cards[index];
          var nextCard = cards[index + 1] || cards[index - 1];

          if (card) {
            this.removeChild(card);
            this.dispatchEvent(new CustomEvent('cardRemoved', {bubbles: true, detail: card}));
            if (card.getAttribute('visible') && nextCard) {
              nextCard.show();
            }
            return card;
          }

          console.error('No such card.');
        },
        countCards: function() {
          return this.querySelectorAll('ceci-card').length;
        },
        clearCards: function() {
          var card;
          while ((card = this.querySelector('ceci-card')) !== null) {
            this.removeChild(card);
          }
        },
        addComponentToCard: function(name, options) {
          options = options || {};
          var card = document.querySelector('ceci-card[visible]');
          if (card) {
            var newElement = document.createElement(name);
            // wait until Polymer has prepared the element completely
            var handle = function() {
              var selectedBrick = card.querySelector(".brick.selected");
              var next = false;
              if (selectedBrick) {
                next = selectedBrick.nextSibling;
              }
              var append = options.append || !next;
              if(append) {
                card.appendChild(newElement);
              } else {
                card.insertBefore(newElement,next);
              }
              // Apply defaults here explicitly so that element doesn't
              // have to figure out whether or not it's new when it's
              // attached to the DOM.
              newElement.applyDefaults();
            };

            newElement.onready(handle);
            return newElement;
          }
        },
        appidChanged: function(){
          this.initFirebase();
        },
        initFirebase: function(){
          var firebaseHost = "https://flathead.firebaseio.com/";

          if (!window.Firebase) {
            console.error('Firebase not loaded. Cannot init for ceci-app.');
            return;
          }

          if(this.appid) {
            this.firebase = new Firebase(firebaseHost+this.appid);
            window.dispatchEvent(new CustomEvent("CeciDataConnectionLoaded"));
          }
        },
        getFirebaseObject: function(childRefPath, itemName, callback){
          if(!this.firebase){
              console.error("Firebase connection was null");
              return null;
          }
          var self = this;
          this.firebase.child(childRefPath).once("value", function(data) {
            callback(data.val());
          });
        },
        setFirebaseObject: function(childRefPath, data){
          if(!this.firebase){
            console.error("Firebase connection was null");
            return null;
          }
          var dataRef = this.firebase.child(childRefPath);
          dataRef.set(data);
        }
      });
    }

    require(['Firebase'], initCeciApp, initCeciApp);
  </script>
</polymer-element>

<polymer-element name="ceci-broadcast" attributes="on from">
  <template>
    <content></content>
  </template>
  <script>
    Polymer('ceci-broadcast', {
      _element: null,
      fire: function (data, extra) {
        var channel = this.on;
        var e = new CustomEvent(channel, {bubbles: true, detail: {
          data: data,
          extra: extra,
          originCeciElement: this._element
        }});
        document.dispatchEvent(e);
      },
      onChanged : function(){
        this.updated();
      },
      fromChanged: function(){
        this.updated();
      },
      detached: function(){
        this.updated("detached");
      },
      updated: function(action){
        var details = { action: action };
        window.dispatchEvent(new CustomEvent('channelUpdate', { detail: details } ));
      },
      attached: function () {
        this.updated();
        this._element = this.parentNode;
      }
    });
  </script>
</polymer-element>

<polymer-element name="ceci-card-base" attributes="visible">
  <template>
    <style>
      :host {
        width: 100%;
        height: 100%;
        display: none;
      }

      :host ceci-top, :host ceci-bottom {
        position: absolute;
        height: 50px;
        width: 100%;
      }

      :host([visible]) {
        display: block;
      }

      :host #middle {
        display: block;
        width: 100%;
      }

      :host #top,
      :host #bottom {
        display: none;
      }

      :host #top {
        border-bottom: dashed 2px #DDD;
        top: 0;
      }

      :host #bottom {
        border-top: dashed 2px #DDD;
        bottom: 0;
      }

      :host #middle {
        top: 15px;
        bottom: 15px;
      }
    </style>
    <ceci-top id="top"></ceci-top>
    <ceci-middle id="middle"><content></content></ceci-middle>
    <ceci-bottom id="bottom"></ceci-bottom>
  </template>
  <script>
    Polymer('ceci-card-base', {
      ready: function () {
      },
      show: function () {
        this.setAttribute('visible', true);
        var that = this;
        var cards = document.querySelectorAll('ceci-card').array();
        cards.forEach(function (card) {
          if (card !== that) {
            card.removeAttribute('visible');
          }
        });
        window.dispatchEvent(new CustomEvent('cardShown', {bubbles: true, detail: this}));
      }
    });
  </script>
</polymer-element>

<polymer-element name="ceci-card-nav">
  <template>
    <link rel="stylesheet" href="/stylesheets/cards.css" >
  </template>
  <script>
  require(['jquery', 'l10n', 'analytics'], function($, l10n, analytics) {
    Polymer('ceci-card-nav', {
      checked : false,
      attached : function(){
        this.buildTabs();
      },
      ready: function() {
        var t = this;

        function resetTabs() {
          t.buildTabs();
        }

        window.addEventListener('cardShown', function(){t.highlightTab();});
        window.addEventListener('cardAdded', resetTabs);
        window.addEventListener('cardRemoved', resetTabs);
        window.addEventListener('resetcards', resetTabs);
        window.addEventListener('CeciElementSortStarted',function(){t.sortHelper();});
        window.addEventListener('CeciElementsSorted',function(){t.sortHelper();});

        // Add card markup to light dom
        var cards = document.createElement("div");
        cards.classList.add("cards");
        var cardlist = document.createElement("div");
        cardlist.classList.add("card-list");
        var addcard = document.createElement("div");
        addcard.classList.add("add-card");
        cards.appendChild(cardlist);
        cards.appendChild(addcard);
        document.querySelector(".top-nav").appendChild(cards);

        $(".add-card").on("click",function(){
          t.addCard();
        });
      },
      sortHelper : function(){
        $(".card-list").toggleClass("bounce");
      },
      highlightTab : function(){
        var highlightIndex;
        var list = document.querySelectorAll("ceci-card").array() || [];
        list.forEach(function(el,index){
          if(el.getAttribute("visible") == "true"){
            highlightIndex = index;
          }
        });
        if(highlightIndex > -1) {
          highlightIndex = highlightIndex + 1;
          $(".card").removeClass("selected");
          $(".card:nth-child("+highlightIndex+")").addClass("selected");
        }
      },
      addCardTab : function(index, card){
        var t = this;
        var newthumb = document.createElement("div");
        function showCard() {
          card.show();
        }
        newthumb.innerHTML = "<span class='card-name'>" + l10n.get("Page") + " " + index + "</span><a title='" + l10n.get("Delete this card") + "' href='#' class='delete-card'></a>";
        newthumb.classList.add("card");
        newthumb.addEventListener("click", showCard);
        newthumb.querySelector("a").onclick = function(e) {
          newthumb.removeEventListener("click", showCard);
          t.getOrWaitForCeciApp(function(ceciApp){
            analytics.event("Delete Page", { label : "Page number " + index});
            ceciApp.removeCard(index-1);
          });
        };
        $(".card-list").append(newthumb);
        $(newthumb).droppable({
          tolerance : "pointer",
          over : function(){
            card.show();
          }
        });

      },
      buildTabs : function() {
        var t = this;
        $(".card-list .card").remove();

        //Add tabs for all pages
        var existingCards = document.querySelectorAll('ceci-card').array();

        if(!existingCards){
          var self = this;
          document.getElementsByTagName('ceci-card')[0].addEventListener('WebComponentReady', function(){
            var existingCards = document.querySelectorAll('ceci-card').array();
            if(existingCards.length > 0){
              existingCards.forEach(function(el,index){
                t.addCardTab(index+1,existingCards[index]);
              });
            }
            this.highlightTab();
          });
        } else {
          if(existingCards.length > 0){
            existingCards.forEach(function(el,index){
              t.addCardTab(index+1,existingCards[index]);
            });
          }
          this.highlightTab();
        }
      },
      addCard : function() {
        this.getOrWaitForCeciApp(function(ceciApp){
          ceciApp.addCard();
          analytics.event("Add Page");
        });
      },
      getOrWaitForCeciApp : function(callback){
        var ca = document.querySelector("ceci-app");
        if(!ca){
          document.getElementsByTagName('ceci-card')[0].addEventListener('WebComponentReady', function(){
            var ca = document.querySelector("ceci-app");
            callback(ca);
          });
        } else {
          callback(ca);
        }
      }
    });
  });
  </script>
</polymer-element>

<polymer-element name="ceci-collection" attributes="collectionname">
  <template>
    <style>
      :host {
        display: none;
      }
    </style>
    <content></content>
  </template>
  <script>
    Polymer('ceci-collection', {
      ready: function() {
        this.data = [];
      },
      attached: function() {
        var dataString = localStorage.getItem("ceci-collections-" + this.getAttribute("collectionname"));
        var savedData = [];
        var self = this;
        if (dataString) {
          try {
            savedData = JSON.parse(dataString);
          } catch (e) {
            console.error("Error parsing saved data:", e);
          }
        }
        this.data = savedData || [];
      },
      addField: function(name, kind) {
        var field = document.createElement("ceci-field");
        this.appendChild(field);
        field.setAttribute("fieldname", name);
        field.kind = kind || "text";
        var detail = {
          added: field
        };
        this.asyncFire("fieldchange", detail);
      },
      removeField: function(name) {
        var field = this.querySelector('ceci-field[fieldname="'+ name + '"]');
        this.removeChild(field);
        var detail = {
          removed: field
        };
        this.asyncFire("fieldchange", detail);
      },
      getField: function(name) {
        return this.querySelector('ceci-field[fieldname="'+ name + '"]');
      },
      getFields: function() {
        return this.querySelectorAll("ceci-field").array();
      },
      collectionnameChanged: function(oldName, newName) {
        var detail = {
          changed: "collectionname",
          removed: oldName,
          added: newName
        };
        this.fire("propertychange", detail);
      },
      addItem: function(item) {
        this.data.push(item);
        var detail = {
          added: item,
          index: this.data.length - 1
        };
        this.saveData();
        this.fire("itemchange", detail);
      },
      removeItem: function(index) {
        var detail = {
          removed: this.data.splice(index, 1)[0],
          index: index
        };
        this.saveData();
        this.fire("itemchange", detail);
      },
      updateItem: function(index, item) {
        var detail = {
          removed: this.data.splice(index, 1, item)[0],
          added: item,
          index: index
        };
        this.saveData();
        this.fire("itemchange", detail);
      },
      saveData: function() {
        localStorage.setItem("ceci-collections-" + this.getAttribute("collectionname"), JSON.stringify(this.data));
      }
    });
  </script>
</polymer-element>

<polymer-element name="ceci-collections">
  <template>
    <style>
      :host {
        display: none;
      }
    </style>
    <content></content>
  </template>
  <script>
    Polymer('ceci-collections', {
      addCollection: function(name) {
        var collection = document.createElement("ceci-collection");
        this.appendChild(collection);
        collection.setAttribute("collectionname", name);
        var detail = {
          added: collection
        };
        this.fire("collectionchange", detail);
      },
      removeCollection: function(name) {
        var collection = this.querySelector('ceci-collection[collectionname="'+ name + '"]');
        this.removeChild(collection);
        var detail = {
          removed: collection
        };
        this.fire("collectionchange", detail);
      },
      getCollection: function(name) {
        return this.querySelector('ceci-collection[collectionname="'+ name + '"]');
      },
      getCollections: function() {
        return this.querySelectorAll("ceci-collection").array();
      },
      getField: function(collectionname, fieldname) {
        return this.querySelector('ceci-collection[collectionname="'+ collectionname + '"]').getField(fieldname);
      },
      getFields: function(name) {
        return this.querySelector('ceci-collection[collectionname="'+ name + '"]').getFields();
      }
    });
  </script>
</polymer-element>


<polymer-element name="ceci-definition">
  <template>
    <style>
      :host {
        display: none;
      }
    </style>
    <content></content>
  </template>
  <script>
    window.CeciDefinitions = window.CeciDefinitions || {};

    Polymer('ceci-definition', {
      alwaysPrepare: true,
      ready: function() {
        this.super();

        var name = this.parentNode.name;
        var jsonString = this.innerHTML;

        try {
          var parsed = JSON.parse(jsonString);
          window.CeciDefinitions[name] = parsed;
        }
        catch (e) {
          console.error('Trouble parsing Ceci definition "' + name + '": ' + e);

          if (window.jsonlint) {
            try {
              jsonlint.parse(jsonString);
              console.error('Unknown Ceci definition string parsing error for this string: ', jsonString);
              alert('The definition for the "' + name + '" component could not be used. Please consult its author for more details.');
            }
            catch (ex) {
              console.error('Failed JSON Lint:', ex);
              alert('The definition for the "' + name + '" component could not be used. Please report this problem to its author.\n\nWhile trying to parse, we found this error:\n\n' + e);
            }
          }
        }
      }
    });
  </script>
</polymer-element>

<polymer-element name="ceci-element-base" attributes="cclsid">
  <template>
    <content></content>
  </template>


  <!-- localization is .ejs generated from views/localization in app.js -->
  <script src="/components/localization.js"></script>

  <!-- base functions and globals -->
  <script>
    // making things easier for devs of all walks of life
    if(!NodeList.prototype.array) { NodeList.prototype.array = Array.prototype.slice; }

    var DEFAULT_CHANNEL = 'blue';

    // Mouse/touch events that need to be routed properly
    var customListenerMap = {
      'on-ceci-pressdown': { eventName: 'ceci-pressdown', mobile: 'touchstart', desktop: 'mousedown' },
      'on-ceci-pressup': { eventName: 'ceci-pressup', mobile: 'touchend', desktop: 'mouseup' }
    };

    // Create a query selector based on the map above, like '[on-ceci-pressdown],[on-ceci-pressup]'.
    var customListenerQuerySelector = Object.keys(customListenerMap).map(function (m) {
      return '[' + m + ']';
    }).join(',');

    function processDefinition (element) {
      var definitionJSON = window.CeciDefinitions[element.localName];

      if (definitionJSON) {
        // Defaults for safety and efficiency :) !
        definitionJSON.tags = definitionJSON.tags || [];
        definitionJSON.thumbnail = definitionJSON.thumbnail || '';
        definitionJSON.listeners = definitionJSON.listeners || {};
        definitionJSON.broadcasts = definitionJSON.broadcasts || {};
        definitionJSON.attributes = definitionJSON.attributes || {};
      }
      else {
        throw new Error("Couldn't find Ceci definition for " + element.localName + ".");
      }

      return definitionJSON;
    }

    function processAttributes (ceciDefinition, attributesDefinitionObject) {
      var result;

      if (!attributesDefinitionObject) return;

      result = {
        listeners: {},
        attributeListeners: {}
      };

      Object.keys(attributesDefinitionObject).forEach(function (attributeName) {
        var attributeDefinition = attributesDefinitionObject[attributeName];

        if (attributeDefinition.listener) {
          var listenerName;

          if (typeof attributeDefinition.listener === 'string') {
            listenerName = attributeDefinition.listener;
          }
          else {
            listenerName = 'set_' + attributeName;
            result.attributeListeners[attributeName] = listenerName;
          }

          result.listeners[listenerName] = {
            description: attributeDefinition.description,
            label: attributeDefinition.label,
            'default': attributeDefinition.defaultListener,
            attribute: attributeName
          };
        }

        if (attributeDefinition.editable) {
          ceciDefinition[attributeName] = {
            description: attributeDefinition.description,
            label: attributeDefinition.label,
            type: attributeDefinition.editable
          };
        }
      });

      return result;
    }

    function processListeners (ceciDefinition, listenersDefinitionObject) {
      var defaultListeners = [];

      if (!listenersDefinitionObject) return defaultListeners;

      Object.keys(listenersDefinitionObject).forEach(function (listenerName) {
        var listenerDefinition = listenersDefinitionObject[listenerName];
        var channel = DEFAULT_CHANNEL;
        ceciDefinition[listenerName] = listenerDefinition;
        if (!!listenerDefinition['default']) {
          if (listenerDefinition['default'] !== true) {
            channel = listenerDefinition['default'];
          }
          defaultListeners.push({name: listenerName, channel: "a" });
        }
      });

      return defaultListeners;
    }

    function processBroadcasts (ceciDefinition, broadcastsDefinitionObject) {
      var defaultBroadcasts = [];

      if (!broadcastsDefinitionObject) return defaultBroadcasts;

      Object.keys(broadcastsDefinitionObject).forEach(function (broadcastName) {
        var broadcastDefinition = broadcastsDefinitionObject[broadcastName];
        var channel = DEFAULT_CHANNEL;
        ceciDefinition[broadcastName] = broadcastDefinition;
        if (!!broadcastDefinition['default']) {
          if (broadcastDefinition['default'] !== true) {
            channel = broadcastDefinition['default'];
          }
          defaultBroadcasts.push({name: broadcastName, channel: "a" });
        }
      });

      return defaultBroadcasts;
    }

    function uid() {
      var rand = (Math.random()*100000000)|0;
      return "uuid-" + Date.now() + "-" + rand;
    }
  </script>



  <!-- Building the actual polymer element -->
  <script>
    Polymer('ceci-element-base', {
      elementReady: false,
      eventListeners : [],
      saveData: function(data) {
        var id;
        if (!this.getAttribute("cclsid")) {
          do { id = uid(); } while(document.querySelector("*[cclsid='"+id+"']"));
          this.setAttribute("cclsid", id);
        }
        id = this.getAttribute("cclsid");
        var storage = { data: data };
        localStorage.setItem("ceci-"+id, JSON.stringify(storage));
      },
      hasData: function() {
        var id = this.getAttribute("cclsid");
        if (!id) return false;
        var storage = localStorage.getItem("ceci-"+id);
        return !!storage;
      },
      loadData: function() {
        var id = this.getAttribute("cclsid");
        if (!id) {
          return console.error("There was no data stored in association with this element");
        }
        var storage = localStorage.getItem("ceci-"+id);
        if (!storage) {
          return false;
        }
        localStorage.removeItem("ceci-"+id);
        try {
          var obj = JSON.parse(storage);
          if (obj.data) {
            return obj.data;
          }
          console.error("The data stored in association with this element did not have a .data payload");
        } catch (e) {
          console.error("The data stored in association with this element could not be parsed");
        }
      },
      sounds : {},
      playSound : function(sound,volume){
        if(this.sounds[sound] && this.ctx){
          if(isNaN(parseFloat(volume))) {
            volume = 1;
          } else {
            volume = parseFloat(volume);
          }
          if(volume > 1) { volume = 1; }
          if(volume < 0) { volume = 0; }
          var gain = this.ctx.createGain();
          gain.gain.value = volume;
          gain.connect(this.ctx.destination);
          var src = this.ctx.createBufferSource();
          src.buffer = this.sounds[sound];
          src.loop = false;
          src.connect(gain);
          src.start(0);
        }
      },
      loadSound : function(soundName,soundPath,app){
        var that = this;
        app = app || document.querySelector("ceci-app");

        if(app && app.Audiocontext) {
          this.ctx = app.Audiocontext;
        } else {
          var handler = function(evt) {
            window.removeEventListener("CeciAppReady", handler);
            that.loadSound(soundName,soundPath,evt.detail.app);
          };
          window.addEventListener("CeciAppReady", handler);
          return;
        }

        var xhr = new XMLHttpRequest();
        xhr.open("GET", this.resolvePath(soundPath), true);
        xhr.responseType = "arraybuffer";
        xhr.onload = function () {
          if (xhr.response.byteLength) {
            that.ctx.decodeAudioData(xhr.response, function(data) {
              that.sounds[soundName] = data;
            },
            function (e) {
              console.error('Error decoding the audio buffer.', arguments);
            });
          }
        };
        xhr.send();
      },
      localize: function() {
        console.error("localize() has not yet been defined by ready().");
      },
      stringsUpdated: function(L10n) {
        this.localize();
        this.fire("LocaleStringsUpdated");
      },
      ready: function () {
        this.sounds = {};
        this.eventListeners = [];
        if (this.ceci) return;
        this.addedCustomListeners = false;

        var that = this;

        this.ceci = {
          broadcasts: {},
          listeners: {},
          editables: {},
          attributes: {},
          description : ""
        };

        this.ceciDefinition = processDefinition(this);

        if (!this.ceciDefinition) {
          console.error('Ceci definition required for ' + this.localName);
          return;
        }

        // bind the localised strings for attributes, unless there is already a stored attribute
        this.localize = (function() {

          this.ceciDefinition = processDefinition(this);

          var attributeResults = processAttributes(this.ceci.editables, this.ceciDefinition.attributes || {});

          Object.keys(attributeResults.attributeListeners).forEach(function (attributeName) {
            var listenerName = attributeResults.attributeListeners[attributeName];
            that[listenerName] = function (value) {
              that[attributeName] = value;
            };
          });

          Object.keys(this.ceciDefinition.listeners).forEach(function (listenerDefinitionName) {
            attributeResults.listeners[listenerDefinitionName] = that.ceciDefinition.listeners[listenerDefinitionName];
          });

          this._defaultListeners = processListeners(this.ceci.listeners, attributeResults.listeners);
          this._defaultBroadcasts = processBroadcasts(this.ceci.broadcasts, this.ceciDefinition.broadcasts);

          this.ceci.thumbnail = this.ceciDefinition.thumbnail;
          this.ceci.description = this.ceciDefinition.description;
          this.ceci.tags = this.ceciDefinition.tags || [];
          this.ceci.attributes = this.ceciDefinition.attributes || {};
          this.ceci.name = this.gettext(this.localName) || this.ceciDefinition.name || this.localName;

          Object.keys(this.ceciDefinition.attributes).forEach(function(key) {
            // we're using get/setAttribute because at this point that[key] is not guaranteed to work yet.
            if (!that.getAttribute(key)) {
              var lkey = that.localName + "/attributes/" + key;
              var lstring = that.gettext(lkey);
              that.setAttribute(key, lstring);
            }
          });

          this.elementReady = true;
          this.fire('CeciElementReady', {});

        }).bind(this);

        this.L10n = loadL10n(this);
      },
      /**
       * Functions passed to onready will either run immediately, if the element is ready,
       * or once the element finishes its initialisation an CeciElementReady get fired off.
       */
      onready: function(fn) {
        fn = fn.bind(this);
        if(this.elementReady) { fn(); }
        else {
          this.addEventListener('CeciElementReady', fn);
        }
      },
      applyDefaults: function () {
        if (!this._defaultListeners && !this._defaultBroadcasts) {
          // component is not ready yet. Schedule a recall based on locale strings being done
          return this.addEventListener("LocaleStringsUpdated", this.applyDefaults);
        }

        // This code should never be moved to "attached" or be applied automatically when
        // the element is added to the page. It must be run explicitly by an external function,
        // since it's hard to detect whether or not this element is really "new" (e.g. someone
        // just added it to their app), or was created from a loaded app. In the latter case,
        // defaults should not be applied. Only when an element is new do we want this function
        // to run.

        var that = this;
        var map = document.querySelector("ceci-channel-map");
        var channel;
        var used = []; //Used channels so we don't use the same one for broadcasting and listening

        this._defaultListeners.forEach(function (d) {
          if (!that.querySelector('ceci-listen[for="' + d.name + '"]')) {
            channel = map.getFreeChannel("listener");
            that.setListener(d.name, channel);
            used.push(channel);
          }
        });

        this._defaultBroadcasts.forEach(function (d) {
          if (!that.querySelector('ceci-broadcast[from="' + d.name + '"]')) {
            channel = map.getFreeChannel("broadcast",used);
            that.setBroadcast(d.name, channel);
          }
        });
      },
      broadcast: function (name, data) {
        var broadcastElement = this.querySelector('ceci-broadcast[from="' + name + '"]');
        if (broadcastElement) {
          if (data === undefined) {
            data = this.gettext(this.localName + "-component/attributes/" + name) || name;
          }
          broadcastElement.fire(data);
        }
      },
      showContainingCard: function () {
        var potentialCard = this.parentNode;

        while (potentialCard && potentialCard.localName !== 'ceci-card') {
          potentialCard = potentialCard.parentNode;
        }

        if (potentialCard) {
          potentialCard.show();
        }
      },
      getActiveListeners: function () {
        return this.querySelectorAll("ceci-listen").array();
      },
      setListener: function (name, channel) {
        var entry = this.ceci.listeners[name];

        if (entry) {
          var listener = this.querySelector('ceci-listen[for="' + name + '"]');
          var original = null;
          if (!listener) {
            listener = document.createElement('ceci-listen');
            this.appendChild(listener);
            listener.setAttribute('for', name);
          } else {
             original = listener.on;
          }
          listener.setAttribute('on', channel);
          this.fire('CeciChannelUpdated', {detail: {name: name, channel: channel, type: 'listen', original: original}});
        }
        else {
          console.error('No listener definition found for "' + name + '".');
        }
      },
      removeListener: function (name) {
        var listen = this.querySelector('ceci-listen[for="' + name + '"]');
        if (listen) {
          this.removeChild(listen);
          this.fire('CeciChannelUpdated', {detail: {name: name, channel: null, type: 'listen', original: listen.on}});
        }
      },
      getActiveBroadcasts: function () {
        return this.querySelectorAll("ceci-broadcast").array();
      },
      setBroadcast: function (name, channel) {
        var entry = this.ceci.broadcasts[name];
        if (entry) {
          var broadcast = this.querySelector('ceci-broadcast[from="' + name + '"]');
          var original = null;
          if (!broadcast) {
            broadcast = document.createElement('ceci-broadcast');
            this.appendChild(broadcast);
            broadcast.setAttribute('from', name);
          } else {
            original = broadcast.on;
          }
          broadcast.setAttribute('on', channel);
          this.fire('CeciChannelUpdated', {detail: {name: name, channel: channel, type: 'broadcast', original: original}});
        }
        else {
          console.error('No broadcast definition found for "' + name + '".');
        }
      },
      removeBroadcast: function (name) {
        var broadcast = this.querySelector('ceci-broadcast[from="' + name + '"]');
        if (broadcast) {
          this.removeChild(broadcast);
          this.fire('CeciChannelUpdated', {detail: {name: name, channel: null, type: 'broadcast', original: broadcast.on}});
        }
      },
      addCustomListener: function(el, listener){
        // Loop over the on-ceci-* listener types to see which one applies to this element
        var that = this;
        Object.keys(customListenerMap).forEach(function (listener) {
          if (!el.hasAttribute(listener)) return;

          // If there is a valid map entry, grab it
          var mapEntry = customListenerMap[listener];

          if(mapEntry) {
            // Fire an event directly at the element with the on-ceci-* attribute
            el.addEventListener(mapEntry[that.touchEnabled ? 'mobile' : 'desktop'], function(e){
              // Emit an event without the "on-" prefix, to let Polymer's template syntax sugar do the rest
              el.dispatchEvent(new CustomEvent(listener.substr(3), {bubbles: true, detail: this}));
            });
          }
        });
      },
      domReady: function () {
        if(!this.addedCustomListeners) {
          this.touchEnabled = 'ontouchstart' in document.documentElement;
          var els = this.shadowRoot.querySelectorAll(customListenerQuerySelector).array();
          els.forEach(this.addCustomListener.bind(this));
          this.addedCustomListeners = true;
        }
        document.dispatchEvent(new CustomEvent('CeciElementAdded', {bubbles: true, detail: this}));
      },
      gettext: function (keyname) {
        return this.L10n.get(keyname);
      }
    });
  </script>
</polymer-element>

<polymer-element name="ceci-field" attributes="kind fieldname">
  <template>
    <style>
      :host {
        display: none;
      }
    </style>
    <content></content>
  </template>
  <script>
    Polymer('ceci-field', {
      kinds: ["Number", "Toggle", "Text", "Name", "Address", "URL", "Color", "Image"],
      kindChanged: function() {
        var detail = {
          changed: "kind"
        };
        this.fire("propertychange", detail);
      },
      fieldnameChanged: function(oldName, newName) {
        var detail = {
          changed: "fieldname",
          added: newName,
          removed: oldName
        };
        this.fire("propertychange", detail);
      },
      getCollectionName: function() {
        return this.parentNode.getAttribute("collectionname");
      }
    });
  </script>
</polymer-element>

<polymer-element name="ceci-listen" attributes="on for">
  <template>
    <content></content>
  </template>
  <script>
    Polymer('ceci-listen', {
      ready: function () {
        var that = this;
        this._eventListener = function(e) {
          // Make sure that this <ceci-listen> is inside a valid ceci element, and that the broadcast which triggered this
          // listener did not originate inside the same ceci element. i.e. an element cannot listen to its own broadcasts.
          if (that._element && that._element !== e.detail.originCeciElement && that._element[that._handler]) {
            that._element[that._handler](e.detail.data, e.detail.extra);
            var listenerDetails = {
              handler : that._handler,
              data : e.detail.data,
              channel : that._channel,
              extra : e.detail.extra
            };
            //This should somehow live in a ceci-listen-designer
            that.dispatchEvent(new CustomEvent('signalFired', {name: name, bubbles: true, detail: listenerDetails}));
          }
        };
      },
      _element: null,
      _handler: null,
      _channel: null,
      _eventListener: null,
      update: function () {
        if (this._channel && this._eventListener && this.parentNode) {
          document.removeEventListener(this._channel, this._eventListener, false);
        }
        this._handler = this.getAttribute('for');
        this._channel = this.getAttribute('on');
        this.updateContainerElement();

        if (this.parentNode) {
          document.addEventListener(this._channel, this._eventListener, false);
        }

        window.dispatchEvent(new CustomEvent('channelUpdate'));

        this.dispatchEvent(new CustomEvent('listenerUpdated', {
          name: name, bubbles: true, detail: this
        }));
      },
      attached: function () {
        this.update();
      },
      detached: function () {
        if (this._channel && this._eventListener) {
          document.removeEventListener(this._channel, this._eventListener, false);
        }
        this.dispatchEvent(new CustomEvent('listenerUpdated', {name: name, bubbles: true, detail: this}));
      },
      updateContainerElement: function () {
        this._element = this.parentNode;
      },
      onChanged: function (oldValue, newValue) {
        this.update();
      },
      forChanged: function (oldValue, newValue) {
        this.update();
      }
    });
  </script>
</polymer-element>

<polymer-element name="ceci-card" extends="ceci-card-base">
  <template>
    <shadow></shadow>
    <style>
      :host {
        min-height: 50px;
      }
    </style>
  </template>

  <script>
    Polymer('ceci-card', {
      brickCount : function(){
        return this.querySelectorAll(".brick").length;
      },
      ready: function() {
        var that = this;
        this.super();
        this.classList.add("ceci-card");

        require(['designer/editable', 'analytics'], function(Editable, analytics) {
          function createSortable() {
            var draggedOff = false;

            $(that).sortable({
              distance : 10,
              handle: '.handle',
              appendTo : "body",
              helper : 'clone',
              connectWith : ".ceci-card",
              placeholder: {
                element: function(clone, ui) {
                  return $("<div class='sortable-placeholder'></div>");
                },
                update: function() {
                  return;
                }
              },
              start : function(){
                that.async(function() {
                  window.dispatchEvent(new CustomEvent('CeciElementSortStarted', {bubbles: true}));
                });
              },
              stop: function(ev, ui) {
                that.async(function() {
                  document.dispatchEvent(new CustomEvent('CeciElementsSorted', {bubbles: true, detail: ui.item[0]}));
                });
              }
            });
          }
          var interval = setInterval(function() {
            if (window.$ && $('<div>').sortable) {
              clearInterval(interval);
              createSortable();
            }
          }, 100);
        });
      }
    });
  </script>
</polymer-element>

<polymer-element name="ceci-channels">
  <script>
    Polymer('ceci-channels', {
      channels : {
        "a":"de0310",
        "b":"e82f0a",
        "c":"ef5106",
        "d":"f87303",
        "e":"f89200",
        "f":"cca108",
        "g":"a0af0e",
        "h":"78bc13",
        "i":"56bb2d",
        "j":"3dac5d",
        "k":"259c8b",
        "l":"0d8bb8",
        "m":"1373d2",
        "n":"3951d2",
        "o":"5f30d2",
        "p":"8a0bd2"
      },
      defaultChannelNames: "abcdefghijklmnop"
    });
  </script>
</polymer-element>

<polymer-element name="ceci-channel-map" attributes="broadcastchannels listenerchannels channels" extends="ceci-channels">
  <template>
    <content></content>
  </template>
  <script>
    Polymer('ceci-channel-map', {
      ready : function(){
        this.app = document.querySelector("ceci-app");
        this.broadcastchannels = this.broadcastchannels || [];
        this.listenerchannels = this.listenerchannels || [];
        this.channelNames = Object.keys(this.channels);
        var that = this;
        this.onChannelUpdate = function(evt) {
          var details = evt.detail;
          if(details && details.action && details.action === "detached") {
            // end of the line for this component, no need to actually update
            return;
          }
          that.getChannels(evt.detail);
        };
        window.addEventListener('channelUpdate', this.onChannelUpdate);
      },
      detached: function() {
        window.removeEventListener('channelUpdate', this.onChannelUpdate);
      },
      defaultIndex : 0,
      getFreeChannel : function(type,used){
        // Order of returned channel:
        // 1 - First unmatched listner / broadcast channel
        // 2 - Next unused channel (cycling from a to z)

        used = used || [];
        this.getChannels();

        var useChannel, matches, doesntmatch;

        if(type == "listener") {
          matches = this.broadcastchannels;
          doesntmatch = this.listenerchannels;
        } else {
          matches = this.listenerchannels;
          doesntmatch = this.broadcastchannels;
        }

        //Return first unused broadcast channel...
        for(var i = 0; i < this.channelNames.length; i++){
          var channelName = this.channelNames[i];
          if(matches.indexOf(channelName) > -1 && used.indexOf(channelName) < 0) {
            if(doesntmatch.indexOf(channelName) < 0) {
              return channelName;
            }
          }
        }

        // ...or fist unused listener channel
        for(var i = 0; i < this.channelNames.length; i++){
          var channelName = this.channelNames[i];
          if(doesntmatch.indexOf(channelName) < 0 && used.indexOf(channelName) < 0) {
            useChannel = channelName;
            break;
          }
        }

        // If no free channels left
        if(!useChannel) {
          useChannel = this.channelNames[this.defaultIndex];
          this.defaultIndex++;
          if(this.defaultIndex >= this.channelNames.length ){
            this.defaultIndex = 0;
          }
        }
        this.lastDefault = useChannel;
        return useChannel;

      },
      getChannels : function(){
        this.map = {};

        var app = document.querySelector("ceci-app");
        var els = app.querySelectorAll("ceci-listen,ceci-broadcast");

        for(var i = 0; i < els.length; i++) {
          var el = els[i];
          var channel = el.on;
          var type = el.hasAttribute("for") ? "listener" : "broadcast";
          var method = el.getAttribute("for") || el.getAttribute("from");

          if(!this.map[channel]) {
            this.map[channel] = {};
          }

          if(!this.map[channel][type]){
            this.map[channel][type] = [];
          }

          this.map[channel][type].push(method);
        }

        this.showChannels();
      },
      showChannels : function(){
        var channelStatus;
        var broadcastChannels = [];
        var listenerChannels = [];
        var that = this;

        Object.keys(this.map).forEach(function(key){
          var channel = that.map[key];
          if(channel.broadcast) {
            broadcastChannels.push(key);
          }
          if(channel.listener) {
            listenerChannels.push(key);
          }
        });

        this.broadcastchannels = broadcastChannels;
        this.listenerchannels = listenerChannels;
      },
      attached : function(){
        this.app = document.querySelector("ceci-app");
      }
    });
  </script>
</polymer-element>

<polymer-element name="ceci-channel-menu" attributes="channeltype" extends="ceci-channels">
  <template>
    <link rel="stylesheet" href="/stylesheets/broadcast-menu.css" >
    <content>
      <div class="channel-menu-wrapper {{channeltype}}"  id="channelMenuWrapper">
        <div class="hover-helper" on-click="{{toggleMenu}}">
          <div class="arrow"></div>
        </div>
        <div id="{{channeltype}}Menu" class="{{channeltype}}-menu channel-menu">
          <div class="arrow-container">
            <div class="arrow"></div>
          </div>
          <div class="channel-option subscription-option option-template">
            <div class="color-ui hidden">
              <h3></h3>
              <div class="color-options"></div>
              <div>
                <div class="channel-button custom-channel-button">Custom</div>
                <input class="hidden custom-channel-input">
              </div>
              <div>
                <div data-color="off" class="channel-button color-button" data-channel="off">Disable</div>
              </div>
            </div>
            <a class="label"><span class="channel-name"></span><div data-color="off" class="chosen-color"></div></a>
          </div>
        </div>
      </div>
    </content>
  </template>
  <script>
    require(['l10n'], function(L10n) {
      Polymer('ceci-channel-menu', {
        menubuilt : false,
        ready : function (){
          this.addEventListener("click", function(e) {
            e.stopPropagation();
          });
        },
        domReady: function () {
          this.menuWrapper = this.shadowRoot.querySelector(".channel-menu-wrapper");
          this.menu = this.menuWrapper.querySelector(".channel-menu");
          var optionsWrapper = this.menuWrapper.querySelector(".color-options");
          this.hideMenu();
          var channelNames = Object.keys(this.channels);
          var customChannels = {};
          var that = this;

          channelNames.sort(function(a, b) {
            if (that.defaultChannelNames.indexOf(a) >= 0 && that.defaultChannelNames.indexOf(b) < 0) {
              return -1
            }
            if (that.defaultChannelNames.indexOf(a) < 0 && that.defaultChannelNames.indexOf(b) >= 0) {
              return 1
            }
            if (a > b) {
              return 1
            }
            if (a < b) {
              return -1
            }
            return 0;
          });

          channelNames.forEach(function(channelName) {
            that.addChannel(channelName, that.channels[channelName], optionsWrapper);
          });

          this.onHideMenu = function(){
            that.hideMenu();
          };

          window.addEventListener("menuOpen", this.onHideMenu);
          window.addEventListener("designerClick", this.onHideMenu);

          this.async(function () {
            that.component = that.parentNode;
            if(!that.menubuilt){
              // Make sure the component is ready enough to start building a menu for it.
              that.component.onready(function() {
                that.buildMenu(that.component);
                that.adjustMenuPosition();
              });
            }

            //Listens for clicks on the channel lines
            var channelLines = that.component.querySelectorAll("ceci-broadcast-vis,ceci-listen-vis");
            for(var i = 0; i < channelLines.length; i++){
              var line = channelLines[i];
              line.addEventListener("channelClick",function(e){
                var method = e.detail.method;
                var direction = e.detail.direction;
                if(that.channeltype === "broadcast" && direction === "out") {
                  that.toggleMenu();
                }
                if(that.channeltype === "listen" && direction === "in") {
                  that.toggleMenu();
                }
                that.showColorUI(method);
              });
            }

          });

        },
        detached: function() {
          window.removeEventListener("menuOpen", this.onHideMenu);
          window.removeEventListener("designerClick", this.onHideMenu);
          window.removeEventListener("customchanneladded", this.onCustomChannelAdded);
        },
        addChannel: function(channelName, color, optionsWrapper) {
          color || "888888";
          var option = document.createElement("div");
          option.classList.add("channel-button");
          option.classList.add("color-button");
          option.textContent = channelName;
          option.style.background = "#" + color;
          option.setAttribute("data-channel",channelName);
          optionsWrapper.appendChild(option);
        },
        toggleMenu : function(){
          this.menuWrapper.classList.toggle("open");
          if(this.menuWrapper.classList.contains("open")){
            window.dispatchEvent(new CustomEvent('menuOpen'));
            this.menu.classList.remove("picking-colors");
            this.menuWrapper.classList.add("open");
            this.addhelperClasses();
            this.adjustMenuPosition();
          } else {
            window.dispatchEvent(new CustomEvent('menuClosed'));
          }
        },
        hideMenu : function() {
          this.menuWrapper.classList.remove("open");

          var channelOptions = this.menuWrapper.querySelectorAll(".channel-option:not(.option-template)");
          for(var i = 0; i < channelOptions.length; i++){
            channelOptions[i].classList.remove("hidden");
          }

          var colorUis = this.menuWrapper.querySelectorAll(".color-ui");
          for(var i = 0; i < colorUis.length; i++){
            colorUis[i].classList.add("hidden");
          }

          var labels = this.menuWrapper.querySelectorAll(".label");
          for(var j = 0; j < labels.length; j++){
            labels[j].classList.remove("hidden");
          }

          window.dispatchEvent(new CustomEvent('menuClosed'));
        },
        adjustMenuPosition : function(){
          this.menu = this.shadowRoot.querySelector(".channel-menu");
          var height = this.menu.offsetHeight;
          this.menu.style.marginTop = "-" + (height/2 + 1) + "px";
        },
        addhelperClasses : function(){

          // Adds hasbroadcast or haslistener classes to the color dots

          var channelMap = document.querySelector("ceci-channel-map");
          var bchans = channelMap.broadcastchannels;
          var lchans = channelMap.listenerchannels;

          var channels = this.shadowRoot.querySelectorAll(".channel-option:not(.option-template) .color-ui .color-button");

          // loops through all the channel dots

          for(var i = 0; i < channels.length; i++) {
            var channelDot = channels[i];
            channelDot.classList.remove("hasbroadcast");
            channelDot.classList.remove("haslistener");

            var thisChannel = channelDot.getAttribute("data-channel");

            for(var j = 0; j < bchans.length; j++){
              var bchannel = bchans[j];
              if(thisChannel == bchannel){
                channelDot.classList.add("hasbroadcast");
              }
            }

            for(var k = 0; k < lchans.length; k++){
              var lchannel = lchans[k];
              if(thisChannel == lchannel){
                channelDot.classList.add("haslistener");
              }
            }

          }
        },
        changeChannel : function(handlerType, handler, color){
          var action = color === 'off' ? 'remove' : 'set';
          var messageType = this.channeltype === 'broadcast' ? 'Broadcast' : 'Listener';
          this.component[action + messageType](handler, color);
        },
        showColorUI : function(method){
          var that = this;
          var channelOption = that.shadowRoot.querySelector(".channel-option[from="+method+"]") || that.shadowRoot.querySelector(".channel-option[for="+method+"]") ;

          channelOption.querySelector(".label").classList.add("hidden");

          that.menu.classList.add("picking-colors");

          //Hide all the options
          var options = that.menu.querySelectorAll(".channel-option");
          for(var i=0, last=options.length; i<last; i++) {
            options[i].classList.add("hidden");
          }

          channelOption.classList.remove("hidden");
          channelOption.querySelector(".color-ui").classList.remove("hidden");
          that.adjustMenuPosition();

        },
        buildMenu: function() {
          this.menubuilt = true;
          var that = this;
          var communicators, handlerType;

          if(this.channeltype == "broadcast") {
            communicators = this.component.ceci.broadcasts;
            handlerType = "from";
          }

          else {
            communicators = this.component.ceci.listeners;
            handlerType = "for";
          }

          function colorListClickHandler(handlerType){
            return function(event) {
              if(event.target.classList.contains("color-button")){

                that.menu.classList.remove("picking-colors");
                var channelOption = event.target.parentNode.parentNode.parentNode;

                var channel = event.target.getAttribute("data-channel");
                var handler = this.parentNode.getAttribute(handlerType);

                that.changeChannel(handlerType, handler, channel);

                //Show all the options again
                var options = that.menu.querySelectorAll(".channel-option:not(.option-template)");
                for(var i=0, last=options.length; i<last; i++) {
                  options[i].classList.remove("hidden");;
                }

                channelOption.querySelector(".label").classList.remove("hidden");
                channelOption.querySelector(".label .chosen-color").setAttribute("data-color", channel);

                var color = that.channels[channel] || "DDD";

                channelOption.querySelector(".label .chosen-color").style.background =  "#" + color;
                if(channel == "off"){
                  channelOption.querySelector(".label .chosen-color").textContent = "";
                } else {
                  channelOption.querySelector(".label .chosen-color").textContent = channel;
                }

                channelOption.querySelector(".color-ui").classList.add("hidden");
                that.adjustMenuPosition();
                that.hideMenu();
              }
            };
          }

          var keys = Object.keys(communicators).sort();

          keys.forEach(function(key) {
            var channelTemplate = that.shadowRoot.querySelector(".option-template");
            var channelOption = channelTemplate.cloneNode(true);
            var optionsWrapper = channelOption.querySelector(".color-options");
            var heading = channelOption.querySelector("h3");
            var headingText;

            this.onCustomChannelAdded = function(e) {
              var channelName = e.detail.channelName;
              var channelColor = "888888";
              that.channels[channelName] = channelColor;
              that.addChannel(channelName, channelColor, optionsWrapper);
            };

            window.addEventListener("customchanneladded", this.onCustomChannelAdded);

            var localizedSetter = L10n.get('Set {attribute}') || 'Set {attribute}';
            var matchLabel = key.match(/[^_]*_(.+)/);

            channelOption.classList.remove("option-template");

            if(matchLabel) {
              channelOption.querySelector(".channel-name").textContent = localizedSetter.replace("{attribute}",
              L10n.get(that.component.localName + "/attributes/" + matchLabel[1] + "/label") || communicators[key].label || key);
              headingText = localizedSetter.replace("{attribute}",
              L10n.get(that.component.localName + "/attributes/" + matchLabel[1] + "/label") || communicators[key].label || key);
            } else {
              channelOption.querySelector(".channel-name").textContent = communicators[key].label || key;
              headingText = communicators[key].label || key;
            }

            if(handlerType === "from") {
              heading.innerHTML = (L10n.get('broadcast') || 'Broadcast') + " <strong>" + headingText + "</strong> " + (L10n.get('on channel...') || 'on channel...');
            } else {
              heading.innerHTML = "<strong>" + headingText + "</strong> " + (L10n.get('when I hear') || 'when I hear a signal on channel...');
            }

            that.menu.appendChild(channelOption);
            channelOption.setAttribute(handlerType, key);
            channelOption.querySelector(".label").setAttribute("title",communicators[key].description);
            channelOption.querySelector(".label").addEventListener('click', function(){
              var method = this.parentNode.getAttribute("from") || this.parentNode.getAttribute("for");
              that.showColorUI(method);
            });

            var colorOptions = channelOption.querySelectorAll(".color-ui .color-button");

            //Check if there's a listener for that element already and set the appropriate color.
            var existingEl = that.component.querySelector("ceci-" + that.channeltype + "["+handlerType+"="+key+"]");

            if(existingEl){
              var color = existingEl.getAttribute("on");
              channelOption.querySelector(".chosen-color").setAttribute("data-color",color);
              channelOption.querySelector(".chosen-color").style.background = "#" + that.channels[color];
              channelOption.querySelector(".chosen-color").textContent = color;
            }

            //Set up all of the click stuff for color options
            channelOption.querySelector(".color-ui").addEventListener("click",colorListClickHandler(handlerType));

            channelOption.querySelector(".custom-channel-button").addEventListener("click", function() {
              var customChannelInput = channelOption.querySelector(".custom-channel-input");
              this.classList.add("hidden");
              customChannelInput.classList.remove("hidden");
              customChannelInput.focus();
              function onClose() {
                customChannelInput.removeEventListener("blur", onClose);
                customChannelInput.removeEventListener("change", onClose);
                var value = this.value.trim();
                if (value) {
                  this.value = "";
                  window.dispatchEvent(new CustomEvent("customchanneladded", {
                    "detail": {
                      "channelName": value
                    }
                  }));
                }
                channelOption.querySelector(".custom-channel-button").classList.remove("hidden");
                customChannelInput.classList.add("hidden");
              }
              customChannelInput.addEventListener("blur", onClose);
              customChannelInput.addEventListener("change", onClose);
            });
          });
        }
      });
    })();
  </script>
</polymer-element>

<polymer-element name="ceci-channel-vis" extends="ceci-channels">
  <script>
  (function(){
    //Animation speeds, In seconds
    var signalSpeed = 0.25;
    var bubbleDuration = 1;
    Polymer('ceci-channel-vis', {
      attached: function () {
        this.component = this.parentNode;
        this.component.addEventListener('CeciChannelUpdated', this.updateChannelVis.bind(this));

        var that = this;

        this.updateChannelElements();
        this.channelElements.forEach(function(el,index){
          var channelname = el.getAttribute("on");
          if (!that.channels[channelname]) {
            that.channels[channelname] = "888888";
          }
        });
      },
      domReady : function(){
        this.updateChannelVis();
      },
      updateChannelElements: function() {
        var inbound = this.direction === "in";
        var elements;

        if(inbound) {
          elements = this.component.querySelectorAll("ceci-listen");
        } else {
          elements = this.component.querySelectorAll("ceci-broadcast");
        }

        this.channelElements = elements.array();
      },
      sortChannelElements: function() {
        var inbound = this.direction === "in";
        this.channelElements.sort(function(a,b) {
          if(inbound) {
            a = a.for;
            b = b.for;
          } else {
            a = a.from;
            b = b.from;
          }
          if(!a || !b) {
            return 0;
          }
          return a === b ? 0 : a<b ? -1 : 1;
        });
      },
      clearChannelLines: function() {
        // Remove all existing channel lines
        var existingLines = this.lines;
        existingLines.innerHTML = "";
      },
      updateChannelVis: function() {
        var that = this;

        this.updateChannelElements();
        this.clearChannelLines();
        this.sortChannelElements();
        this.channelElements.forEach(function(el,index){
          el.addEventListener('signalFired', function(data){
            that.fire(data);
          });

          var channel = document.createElement("div");

          channel.innerHTML = "<div class='dot color'></div><div class='chan-label'></label>";
          channel.setAttribute("color",el.getAttribute("on"));

          var channelname = el.getAttribute("on");
          var label = channel.querySelector(".chan-label");
          label.textContent = channelname.toUpperCase();

          function hexToRgb(hex) {
            if(hex){
              var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
              return parseInt(result[1], 16) + "," + parseInt(result[2], 16) + "," + parseInt(result[3], 16);
            }
          }

          var channelColor = that.channels[channelname];
          var rgb = hexToRgb(channelColor);

          label.style.background = "#" + channelColor;

          if(that.direction == "in") {
            channel.setAttribute("for",el.getAttribute("for"));
            channel.classList.add("in-channel-direction");
            channel.style.backgroundImage = "-moz-linear-gradient(left,rgba("+rgb+",0),rgba("+rgb+",.3))";
            channel.style.backgroundImage = "-webkit-linear-gradient(left,rgba("+rgb+",0),rgba("+rgb+",.3))";

          } else {
            channel.classList.add("out-channel-direction");
            channel.style.backgroundImage = "-webkit-linear-gradient(left,rgba("+rgb+",.3),rgba("+rgb+",0))";
            channel.style.backgroundImage = "-moz-linear-gradient(left,rgba("+rgb+",.3),rgba("+rgb+",0))";
            channel.setAttribute("from",el.getAttribute("from"));
          }

          channel.addEventListener('click', function(e){
            var method;
            if(channel.hasAttribute("for")){
              method = channel.getAttribute("for");
            } else {
              method = channel.getAttribute("from");
            }

            that.dispatchEvent(new CustomEvent('channelClick',{ detail: {
              method : method,
              direction : that.direction
            }}));
            e.stopPropagation();

          });


          channel.classList.add("channel");
          that.$.visLines.appendChild(channel);
        });
      },
      fire : function (data) {
        var channel = data.detail.channel;
        var handler = data.detail.handler;

        // Use async to make sure this component it ready to rock before doing any DOM work on itself.
        this.async(function () {
          var element;
          if(this.direction == "in") {
            element = this.shadowRoot.querySelector(".channel[color='"+channel+"'][for='"+handler+"']");
          } else {
            element = this.shadowRoot.querySelector(".channel[color='"+channel+"'][from='"+handler+"']");
          }

          // Add a signal indicator dot...
          var indicator = document.createElement("div");
          element.appendChild(indicator);

          indicator.classList.add("indicator");
          indicator.classList.add("indicator-" + this.direction);

          var color = "#" + this.channels[element.getAttribute("color")];

          indicator.style.background = color;

          var removeIndicator = function() {
            element.removeChild(indicator);
          };

          setTimeout(removeIndicator, signalSpeed * 1000);

          var timeout = 0;

          setTimeout(function() {
            var bubble = document.createElement("div");
            bubble.textContent = data.detail.data;
            bubble.classList.add("bubblepopup");
            bubble.classList.add("bubblepop");
            bubble.style.color = color;
            bubble.style.borderColor = color;
            element.appendChild(bubble);

            setTimeout(function() {
              element.removeChild(bubble);
            }, bubbleDuration * 1000);
          }, timeout);
        });
      }
    });
    })();
  </script>
</polymer-element>

<polymer-element name="ceci-broadcast-vis" extends="ceci-channel-vis">
  <template>
    <link rel="stylesheet" href="/stylesheets/channel-vis.css" >
    <link rel="stylesheet" href="/stylesheets/animations.css" >

    <div id="visLines" class="channel-visualisation broadcast-channels"></div>
  </template>
  <script>

    Polymer('ceci-broadcast-vis', {
      ready: function() {
        this.lines = this.shadowRoot.querySelector(".channel-visualisation");
        this.direction = "out";
        this.super();
      },
      // broadcasts can cause data sending:
      attached: function () {
        var that = this;
        this.component = this.parentNode;
        this.component.addEventListener('broadcastFired', function(data){
          that.fire(data);
        });
        this.super();
      },
      detached : function(){
        this.component.removeEventListener('broadcastFired');
        this.super();
      }
    });

  </script>
</polymer-element>

<polymer-element name="ceci-listen-vis" extends="ceci-channel-vis">
  <template>
    <link rel="stylesheet" href="/stylesheets/channel-vis.css" >
    <link rel="stylesheet" href="/stylesheets/animations.css" >

    <div id="visLines" class="channel-visualisation subscription-channels"></div>
  </template>
  <script>

    //Animation speeds, In seconds
    Polymer('ceci-listen-vis', {
      ready: function() {
        this.lines = this.shadowRoot.querySelector(".channel-visualisation");
        this.direction = "in";
        this.super();
      }
    });

  </script>
</polymer-element>

<!-- this applies to Light DOM elements, so lives outside the template -->
<link rel="stylesheet" href="/stylesheets/designer-element.css">
<polymer-element name="ceci-element" extends="ceci-element-base">
  <template id="ceci-element">
    <style>
      :host {
        position: relative;
      }
    </style>
    <content></content>
  </template>
  <script>
    Polymer('ceci-element', {
      ready: function() {
        this.super();
        this.classList.add("brick");

        // Just to preserve "this" for event handlers
        this._cleanUp = this.cleanUp.bind(this);
        this._cloneBrick = this.cloneBrick.bind(this);
      },
      broadcast: function(name, data) {
        this.super(arguments);
        var broadcastElement = this.querySelector('ceci-broadcast[from="' + name + '"]');
        if (broadcastElement) {
          this.log(broadcastElement.on, 'broadcasts', name);
          if (data === undefined) {
            data = this.gettext(this.localName + "-component/attributes/" + name) || name;
          }
          var broadcastDetails = {
            channel : broadcastElement.on,
            handler : name,
            data: data
          };
          this.dispatchEvent(new CustomEvent('broadcastFired', {name: name, bubbles: true, detail: broadcastDetails}));
        }
      },
      log: function(eventChannel, eventType, eventName) {
        var message = {};
        message.component = this.tagName.substr(5);
        message.eventChannel = eventChannel;
        message.eventType = eventType;
        message.eventName = eventName;
        this.dispatchEvent(new CustomEvent('log', {bubbles: true, detail: message}));
      },
      cloneBrick : function(){
        var clone = this.cloneNode();
        clone.applyDefaults();
        var next = this.nextSibling;
        if(next){
          this.parentNode.insertBefore(clone,next);
        } else {
          this.parentNode.appendChild(clone);
        }
        this.classList.remove("selected");
        this.classList.remove("last-selected-on-page");
        document.dispatchEvent(new CustomEvent('CeciElementAdded', {bubbles: true, detail: clone}));
      },
      cleanUp: function () {
        // Remove myself from the DOM!
        this.parentNode.removeChild(this);

        var that = this;
        require(['designer/editable', 'analytics'], function (Editable, analytics) {
          Editable.removeAttributes();
          document.dispatchEvent(new CustomEvent('CeciElementRemoved', {bubbles: true, detail: that}));
          analytics.event("Removed Component", { label: that.localName });
        });
      },
      attached: function() {
        this.super();
        var that = this;

        this.onready(function(){

          var hasBroadcasts = Object.keys(that.ceci.broadcasts).length > 0 ? true : false;
          var hasListeners = Object.keys(that.ceci.listeners).length > 0 ? true : false;

          if(!that.querySelector('ceci-channel-menu')) {
            if(hasListeners) {
              var listenMenu  = document.createElement("ceci-channel-menu");
              listenMenu.setAttribute("channeltype","listen");
              that.appendChild(listenMenu);
              var listenVis  = document.createElement("ceci-listen-vis");
              that.appendChild(listenVis);
            }
            if(hasBroadcasts) {
              var broadcastVis  = document.createElement("ceci-broadcast-vis");
              that.appendChild(broadcastVis);
              var broadcastMenu  = document.createElement("ceci-channel-menu");
              broadcastMenu.setAttribute("channeltype","broadcast");
              that.appendChild(broadcastMenu);
            }
          }
        });

        //Set up the brick manipulation UI
        if(this.querySelector(".brick-ui")) {
          this.removeChild(this.querySelector(".brick-ui"));
        }

        var brickUI = document.createElement("div");
        brickUI.classList.add("brick-ui");
        var brickInner = document.createElement("div");
        brickInner.classList.add("brick-ui-inner");
        brickUI.appendChild(brickInner);
        this.appendChild(brickUI);

        var icon = document.createElement("div");
        icon.classList.add("icon");

        // Add "Move Brick" UI
        if(this.querySelector(".handle")){
          this.removeChild(this.querySelector(".handle"));
        }
        var handle = document.createElement('a');
        handle.setAttribute("title","Move this brick.");
        handle.className = 'handle cecidesigner';
        handle.appendChild(icon.cloneNode());
        brickInner.appendChild(handle);

        // Add "Clone Brick" UI
        if(this.querySelector(".clone-brick")){
          this.removeChild(this.querySelector(".clone-brick"));
        }
        var clone = document.createElement('a');
        clone.setAttribute("title","Duplicate this brick.");
        clone.className = 'clone-brick cecidesigner';
        clone.appendChild(icon.cloneNode());
        brickInner.appendChild(clone);
        this.querySelector(".clone-brick").addEventListener("click", this._cloneBrick);

        // Add "Delete Brick" UI
        if(this.querySelector(".garbage")){
          this.removeChild(this.querySelector(".garbage"));
        }
        var garbage = document.createElement('a');
        garbage.setAttribute("title","Delete this brick.");
        garbage.className = 'garbage cecidesigner';
        garbage.appendChild(icon.cloneNode());
        brickInner.appendChild(garbage);
        this.querySelector(".garbage").addEventListener("click", this._cleanUp);

      },
      detached: function () {
        this.querySelector(".clone-brick").removeEventListener("click", this._cleanUp);
        this.querySelector(".garbage").removeEventListener("click", this._cleanUp);
      }
  });
  </script>
</polymer-element>

<polymer-element name="ceci-notifications" attributes="">
  <template>
    <link rel="stylesheet" href="/stylesheets/notifications.css" >
    <content></content>
    <div class="note note-template">
      <div class="dismiss"></div>
      <div class="message"></div>
    </div>
  </template>
  <script>
    Polymer('ceci-notifications', {
      showDuration : 2200,
      ready : function(){
        var that = this;
        window.addEventListener('notification', function(e){
          that.showNotification(e.detail);
        });
      },
      showNotification : function(e){
        var that = this;
        var el = this.shadowRoot.querySelector(".note-template").cloneNode(true);
        el.classList.remove("note-template");
        el.classList.add("note-in");
        el.setAttribute("data-type",e.type);
        el.querySelector(".message").textContent = e.message;
        this.shadowRoot.appendChild(el);
        el.style.left = "calc(50% - " + el.offsetWidth/2 + "px)";

        var removeDelay = window.setTimeout(function(){
          that.hideNotification(el);
        },that.showDuration);

        el.addEventListener("click",function(){
          that.hideNotification(el);
          window.clearTimeout(removeDelay);
        });
      },
      hideNotification: function(el){
        var that = this;
        el.classList.remove("note-in");
        el.classList.add("note-out");
        window.setTimeout(function(){
          that.shadowRoot.removeChild(el);
        },100);
      }
    });
  </script>
</polymer-element>

<polymer-element
  name="designer-component-tray-item"
  attributes="name description label author updatedat thumbnail">
  <template>
    <link rel="stylesheet" href="/stylesheets/designer-component-tray-item.css">
    <div class="add-component component-card" name="{{name}}" show="true" on-click="{{clicked}}">
      <div class="more-info">
        <div class="image-wrapper"><img src="{{thumbnail}}"></div>
        <p class="description">{{description}}</p>
        <div class="arrow-wrapper"></div>
      </div>
      <div class="component-description">
        <h1>
          {{label}}
          <div id="showInfo" on-mouseenter="{{showPopup}}" on-mouseout="{{hidePopup}}"></div>
        </h1>
      </div>
      <a class="show-more" href="#">More Info</a>
    </div>
  </template>
  <script>
    var floatingMoreInfoPopup;

    Polymer('designer-component-tray-item', {
      ready: function(){
        var that = this;
        window.addEventListener('designerClick', function(){
          that.hidePopup();
        });
      },
      hidePopup :function(){
        if (floatingMoreInfoPopup) {
          floatingMoreInfoPopup.parentNode.removeChild(floatingMoreInfoPopup);
          floatingMoreInfoPopup = null;
        }
      },
      adjustPopup : function(){
        var height = floatingMoreInfoPopup.offsetHeight;
        var left = document.querySelector('.tray').offsetWidth;
        var offset = document.querySelector('#components-wrapper').scrollTop;
        var pos = this.offsetTop;
        floatingMoreInfoPopup.style.top = pos + 68 - (height/2) - offset + "px";
        floatingMoreInfoPopup.style.left = left + 16 + "px";
      },
      showPopup :function(){
        this.hidePopup();
        floatingMoreInfoPopup = this.shadowRoot.querySelector('.more-info').cloneNode(true);
        document.querySelector('body').appendChild(floatingMoreInfoPopup);
        var img = floatingMoreInfoPopup.querySelector('img');
        var that = this;
        img.addEventListener('load', function() {
          if (floatingMoreInfoPopup) {
            floatingMoreInfoPopup.querySelector(".image-wrapper").classList.add('loaded');
            that.adjustPopup(floatingMoreInfoPopup);
          }
        }, false);
        this.adjustPopup(floatingMoreInfoPopup);
      },
      clicked: function (e) {
        if (e.target !== this.$.showInfo) {
          this.fire('ComponentAddRequested');
        }
      }
    });
  </script>
</polymer-element>

<polymer-element name="user-state" attributes="user editingmode customcomponents">
  <template>
    <link rel="stylesheet" href="/stylesheets/user-state.css">
    <link rel="stylesheet" href="/vendor/font-awesome/css/font-awesome.css">
    <div>

      <div class="menu-wrapper app-menu button">
        <div class="menu-button" on-mousedown="{{toggleMenu}}">
          <div class="icon-reorder"></div>
        </div>
        <div class="menu app-actions menu-options">
          <a class="saved {{ {hidden: user.state == 'signedout'} | tokenList}}" id="saveAppAs"><span class="icon icon-save"> </span> {{'Save As' | l10n}}</a>
          <a class="saved {{ {hidden: user.state == 'signedout'} | tokenList}}" id="renameApp"><span class="icon icon-edit"> </span> {{'Rename' | l10n}}</a>
          <a class="{{ {hidden: user.state == 'signedout'} | tokenList}}" id="publishApp"><span class="icon icon-mobile-phone"> </span> {{'Publish' | l10n}}</a>
          <a class="{{ {hidden: user.state == 'signedout'} | tokenList}} saved" id="deleteApp"><span class="icon icon-trash"> </span> {{'Delete' | l10n}}</a>
          <a id="newApp"><span class="icon icon-file-alt"> </span> {{'New App' | l10n}}</a>
          <a class="hidden" id="viewlink"><span class="icon icon-external-link"> </span> {{'Preview App' | l10n}}</a>
        </div>
      </div>

      <div class="menu-wrapper user-menu button {{ {hidden: user.state == 'signedout'} | tokenList}}">

        <div id="username" class="menu-button user-menu-button" on-mousedown="{{toggleMenu}}">
          <img class="user-avatar" alt="User avatar" src="{{user.avatar}}">
          {{'Hi' | l10n}} <strong>{{user.username}}</strong>
          <span class="icon icon-caret-down"></span>
        </div>
        <div class="menu">
          <h3 id="myappsheading">{{'My apps' | l10n}}</h3>
          <span id="noApps">{{"You don't have any saved apps!" | l10n}}</span>
          <ul id="myapps" class="menu-options">
          </ul>
          <template if="{{ customcomponents }}">
            <h3 id="mycomponentsheading">{{'My components' | l10n}}</h3>
            <div>
              <a id="addComponent" class="button" on-click={{addComponent}}>{{'Add Component' | l10n}}</a>
            </div>
            <ul id="mycomponents" class="menu-options">
            </ul>
          </template>
          <a id="signout" class="button" on-click="{{signoutClick}}">{{'Sign Out' | l10n}}</a>
        </div>
      </div>
    </div>

    <a class="saveApp saved button green-button {{ {hidden: user.state == 'signedout'} | tokenList}}" id="saveApp">{{'Save App' | l10n}}</a>

<!--
    commented off for https://github.com/mozilla-appmaker/appmaker/issues/1618, with the intention of turning it back on after Maker Party
    <a id="collaborate" class="button" on-click="{{collaborateClick}}">
      {{ {'Collaborate': !user.collaborating} | tokenList}}
      {{ {'End Collaboration': !!user.collaborating} | tokenList}}
    </a>

-->
    <a id="signin" class="button {{ {hidden: user.state == 'signedin'} | tokenList}}" on-click="{{signinClick}}">{{'Sign In' | l10n}}</a>
    <div id="signInProgress" class="hidden"></div>

    <div class="back-to-webmaker">
      <a href="https://webmaker.org/en-US"><span class="webmaker-icon"></span>Webmaker.org</a>
    </div>

  </template>
  <script>
  (function() {

    function init(togetherjs_extension, l10n, jquery, application, tray, utils, reporter, analytics, persona, WebmakerAuthClient) {

      var user = {
        email: '',
        state: 'signedout',
        preventLoadedAppInsertion: false,
        collaborating: false
      };

      var auth = new WebmakerAuthClient();

      auth.on('login', function(data, reason) {
        if (reason === 'restored') {
          return;
        }
        document.dispatchEvent(new CustomEvent("signInFinished"));
        document.querySelector("#publish-pane-panel-email").setAttribute('placeholder', data.email);
        reporter.consoleReport("You have been logged in as: " + data.email);
        document.dispatchEvent(new CustomEvent('user-state', {
          detail: {'state': 'signedin', 'data': data}
        }));
      });

      auth.on('logout', function() {
        document.querySelector("#publish-pane-panel-email").setAttribute('placeholder', 'Your Email');
        document.dispatchEvent(
          new CustomEvent('user-state', {
            detail: {'state': 'signedout', 'data': {}}
          })
        );
      });

      Polymer('user-state', {
        l10n: function (str) {
          return l10n.get(str);
        },
        user: user,
        editingmodeChanged : function(oldValue, newValue){
          localStorage.editingmode = newValue;
          var appNameEl = document.querySelector(".phone-top .app-name");
          if(newValue == "saved"){
            this.classList.add("saved");
            appNameEl.classList.add("saved");
          } else {
            this.classList.remove("saved");
            appNameEl.classList.remove("saved");
          }
        },
        ready: function() {
          var that = this;

          this.addEventListener("click", function(e) {
            e.stopPropagation();
          });

          function loadRemixContent (remixName) {
            var remixedFrom = decodeURIComponent(remixName);
            that.getOrWaitForCeciApp(function(ceciApp){
              if (ceciApp && remixedFrom) {
                ceciApp.remixedfrom = remixedFrom;
              }
            });
            application.loadAppByUrl(remixedFrom, function(error, data) {
              if (error) {
                return that.failedAppLoad();
              }

              that.editingmode = 'remix';
              that.updateAppName(l10n.get("Remix of") + " " + data.getAttribute("name"));
              analytics.event("Loaded Remix Content");
            });
          }

          function setupTempApp() {
            if(!document.querySelector("ceci-app")) {
              var phoneBorderElement = document.querySelector(".phone-border");
              var ca = document.createElement("ceci-app");
              phoneBorderElement.appendChild(ca);
              ca.setAttribute("appid","temp-"+uuid());
              that.updateAppName(l10n.get("Unsaved App"));
              that.editingmode = "draft";
              window.dispatchEvent(new CustomEvent("resetcards"));
            }
          }

          document.addEventListener('signInStarted', function (event) {
            that.signInStarted();
          });

          document.addEventListener('signInFinished', function (event) {
            that.signInFinished();
          });

          document.addEventListener('user-state', function (event) {
            that.user.state = event.detail.state;
            that.user.email = event.detail.data.email;
            that.user.avatar = event.detail.data.avatar;
            that.user.username = event.detail.data.username;

            var remixName = utils.getQueryStringVariable('remix');
            var storedAppName = application.getStoredAppName();
            var editName = utils.getQueryStringVariable('edit');
            if (editName) {
              application.setStoredAppName(decodeURIComponent(editName));
              storedAppName = editName;
            }

            if (that.user.state == 'signedin') {
              that.refreshUserState();
              if (!user.preventLoadedAppInsertion) {
                if(storedAppName){
                  application.loadAppByName(storedAppName);
                  that.editingmode = "saved";
                  that.updateAppName(storedAppName);
                } else {
                  setupTempApp();
                }
              }
              analytics.event("Signed In");
            }
            else if (that.user.state == 'signedout') {
              if (!user.preventLoadedAppInsertion) {
                setupTempApp();
              }
              that.signedOut();
              analytics.event("Signed Out");
            }
          }, false);

          // prepare a temp app regardless of what navigator.id is doing so that user can start playing immediately
          var remixName = utils.getQueryStringVariable('remix');
          if (remixName) {
            loadRemixContent(remixName);
            user.preventLoadedAppInsertion = true;
          }
          else {
            var tutorialActive = utils.getQueryStringVariable('tutorial');
            if (tutorialActive) user.preventLoadedAppInsertion = true;
            setupTempApp();
          }

          window.addEventListener('CeciElementAdded', function (e) {
            user.preventLoadedAppInsertion = true;
          }, false);

          auth.verify();
        },
        enteredView : function() {
          var self = this;

          //This closes the menus when an action is clicked in a menu.
          var menus = this.shadowRoot.querySelectorAll(".menu");
          for(var j = 0; j < menus.length ; j++){
            menus[j].addEventListener('click',function(e){
              if(e.target.tagName == "A"){
                self.closeMenus();
              }
            });
          }

          //Delete app
          this.$.deleteApp.addEventListener('click', function() {
            var ceciApp = document.querySelector('ceci-app');
            var name = ceciApp.name;

            if(!reporter.confirm("Are you sure you want to delete '"+name+"'?"))
              return;
            application.deleteAppByName(name);
            application.clearStoredAppName();
            self.$.newApp.click();
            analytics.event("Deleted App");
          });

          //New app
          this.$.newApp.addEventListener("click",function() {

            // If there are bricks in the app and we're in draft mode,
            // confirm possible loss of work.
            if(self.editingmode !== "saved"){
              var hasBricks = false;
              var cards = document.querySelectorAll("ceci-card").array();
              for(var i = 0; i < cards.length; i++) {
                if(cards[i].brickCount() > 0){
                  hasBricks = true;
                  break;
                }
              }
              if(hasBricks) {
                if(!window.confirm(l10n.get("Lose Work"))){
                  return;
                }
              }
            }

            application.clearStoredAppName();
            application.newApp();
            self.closeMenus();
            self.setAppURL(false);
            self.refreshUserState();
            self.updateAppName(l10n.get("Unsaved App"));
            self.editingmode = "draft";
            window.dispatchEvent(new CustomEvent("resetcards"));
            analytics.event("New App Started");
          });

          function renameAppHandler() {
            var oldName = application.getStoredAppName();
            var newName = window.prompt(l10n.get("What do you want to call this app?"));
            self.renameApp(oldName, newName);
          }

          //Rename App
          this.$.renameApp.addEventListener("click", renameAppHandler);

          //Save App As
          var saveAsHandler = function() {
            var name = "";
            var ceciApp = document.querySelector('ceci-app');
            if (self.editingmode === "remix") {
              name = window.prompt(l10n.get("What do you want to call this remix?"), ceciApp.getAttribute("name"));
            } else {
              name = window.prompt(l10n.get("What do you want to call this app?"));
            }
            self.saveAppAs(name);
          };

          this.$.saveAppAs.addEventListener("click", saveAsHandler);
          document.querySelector(".app-name").addEventListener("click", renameAppHandler);

          //Save App
          this.shadowRoot.querySelectorAll(".saveApp").array().forEach(function(e){
            e.addEventListener("click", function() {
              var ceciApp = document.querySelector('ceci-app');
              var html = ceciApp.outerHTML;
              var name = ceciApp.getAttribute("name");

              if(self.editingmode !== "saved"){
                saveAsHandler();
                return;
              }

              if(name){
                application.saveOrUpdateApp(name,ceciApp.appid,html, function(err,data){
                  if(!err){
                    reporter.consoleReport("App save.");
                    analytics.event("Saved App");
                    reporter.successReport(
                      l10n.get("App saved!")
                    );
                  } else {
                    reporter.errorReport(
                      l10n.get("Your app could not be saved at this time. Please try again."),
                      (err.responseJSON ? l10n.get("Reason:") + " " + l10n.get(err.responseJSON.error) : '')
                    );
                    analytics.event("Error Saving App", { nonInteraction: true });
                  }
                });
              }
            });
          });

          //Publish!
          this.$.publishApp.addEventListener("click", function() {
            var app = document.querySelector('ceci-app');

            // Need to use querySelector because first-child returns null (bug?)
            app.querySelector("ceci-card").show();

            var name = app.getAttribute("name");
            // This is a new app, so get a new name for it.
            if (self.editingmode !== "saved" || !name || name === l10n.get("Unsaved App")) {
              // window.prompt needs to be made its own thing so it can be called
              // in various places:
              if (self.editingmode === "remix") {
                name = window.prompt("Please name your remix first:", name);
              } else {
                name = window.prompt("Please name your app first:");
              }
              if (name === null) {
                return self.appRenameFailed(l10n.get("Save was cancelled."));
              } else if (!name.trim()) {
                return self.appRenameFailed(l10n.get("App names can't be blank."));
              }
              app.setAttribute("name", name);
              app.setAttribute("appid", "ceci-app-"+uuid());
            }

            function afterPublish(err,data) {
              if(err) {
                if (data) {
                  // FIXME: will this route ever fire? The combination of an error + data seems unlikely
                  reporter.errorReport("app was published, but updating failed");
                  analytics.event("Error Updating Published App", { nonInteraction: true });
                } else {
                  if (err.responseJSON.error === 'App name must be unique.') {
                    self.appRenameFailed(l10n.get('App name must be unique.'));
                  } else {
                    reporter.errorReport("app was not successfully published");
                  }
                  analytics.event("Error Publishing App", { nonInteraction: true });
                }
                return;
              }
              application.setStoredAppName(name);
              self.refreshUserState();
              self.editingmode = "saved";
              analytics.event("Published App");
            }
            var options = {
              name: name,
              appDescription: app.appdescription,
              appTags: app.apptags,
              appid: app.appid,
              remixedFrom: app.remixedfrom,
              html: app.outerHTML,
              afterPublish: afterPublish
            };
            application.publishApp(options);
          });
        },
        renameApp: function(oldName, newName) {
          if(typeof newName !== "string") return;
          if(newName.trim()){
            application.renameApp(oldName, newName);
            analytics.event("Renamed App");
          } else {
            this.appRenameFailed(l10n.get("App names can't be blank."));
          }
        },
        saveAppAs: function(name) {
          var ceciApp = document.querySelector('ceci-app');
          var html = ceciApp.outerHTML;
          var self = this;

          if (name === null) {
            self.appRenameFailed(l10n.get("Save was cancelled."));
          } else if(name.trim()){
            application.saveApp(name,ceciApp.appid,html, function(err,data){
              if(!err){
                application.setStoredAppName(name);
                self.refreshUserState();
                self.updateAppName(name);
                ceciApp.setAttribute("appid", "ceci-app-"+uuid());
                self.editingmode = "saved";
                window.dispatchEvent(new CustomEvent("CeciAppSaveAs"));
                analytics.event("Saved App As");
                reporter.successReport(
                  l10n.get("App saved!")
                );
              } else {
                if (err.responseJSON.error === 'App name must be unique.') {
                  self.appRenameFailed(l10n.get('App name must be unique.'));
                } else {
                  reporter.errorReport(
                    l10n.get("Your app couldn't be saved."),
                    (err.responseJSON ? l10n.get("Reason:") + " " + l10n.get(err.responseJSON.error) : '')
                  );
                }
                analytics.event("Error Saving App As", { nonInteraction: true });
              }
            });
          } else {
            self.appRenameFailed(l10n.get("App names can't be blank."));
          }
        },
        signInStarted: function(){
          this.$.signInProgress.classList.remove("hidden");
        },
        signInFinished: function(){
          this.$.signInProgress.classList.add("hidden");
          this.$.signin.classList.add("hidden");
        },
        signedOut: function(){
          this.$.signin.classList.remove("hidden");
        },
        failedAppLoad: function(){
          application.clearStoredAppName();

          var phoneBorderElement = document.querySelector(".phone-border");
          var ca = document.createElement("ceci-app");
          ca.setAttribute("appid", "temp-"+uuid());
          phoneBorderElement.appendChild(ca);
          this.updateAppName(l10n.get("Unsaved App"));
        },
        okAppLoad: function(name, data){
          this.updateAppName(name);
          this.refreshUserState();
          this.setAppURL(data['last-published-url']);
        },
        getOrWaitForCeciApp: function(callback){
          var ceciApp = document.querySelector("ceci-app");
          if(!ceciApp){
            window.addEventListener("CeciAppDOMReady", function(e){
              var ceciApp = document.querySelector("ceci-app");
              callback(ceciApp);
            });
          } else {
            callback(ceciApp);
          }
        },
        updateAppName: function(name){
          this.getOrWaitForCeciApp(function(ceciApp){
            if (ceciApp && name) {
              ceciApp.setAttribute("name", name);
              document.querySelector(".phone-top .app-name").textContent = name;
            }
          });
        },
        appRenameOk: function(name){
          // Rename OK, update the current working app.
          application.setStoredAppName(name);
          this.updateAppName(name);
          this.refreshUserState();
        },
        appRenameFailed: function(message){
          // Rename failed, revert to last known good app name
          this.updateAppName(document.querySelector('ceci-app').name || application.getStoredAppName());
          reporter.errorReport(message);
        },
        signinClick: function() {
          auth.login();
        },
        signoutClick: function() {
          auth.logout();
        },
        loadLink: function(name, url, callback) {
          if (!this.customcomponents) {
            callback({
              error: 'Custom components are not available in this build'
            });
            return;
          }

          var link = document.createElement('link');
          link.rel = "import";
          link.href = url;

          link.onload = function (e) {
            callback(null, link);
          };

          link.onerror = function (e) {
            reporter.errorReport('Failed to load component at ' + url);
            callback({
              error: 'Failed to load component',
              url: url,
              name: name
            });
          };

          document.head.appendChild(link);
        },
        signalComponentError: function(err) {
          reporter.errorReport(err);
          if(arguments.length > 1) {
            Array.prototype.slice.call(arguments, 1).forEach(function(data) {
              reporter.errorReport(data);
            });
          }
          reporter.errorReport(err);
          return;
        },
        addComponentByURL: function (url) {
          if (!this.customcomponents) { return; }

          var self = this;

          try {
            // first, detect github moniker and turn those into known URL structures
            // (we don't know that there is a component at that URL though (in particular if
            // they don't have GH pages setup)
            var chunked = url.split('/');
            if (chunked.length === 2 && chunked[0].indexOf(".") === -1 && url.indexOf('http') === -1) {
              var parts = url.split('/').map(function(v) { return v.trim(); });
              // We're assuming it's a username/repo, and assuming component.html as the leafname.
              url = this.mkGitHubURL(parts[0], parts[1]);
            }
            else {
              // Reject URLs without a protocol
              // (if it's not on http or https, it's not an acceptable URL)
              if (url.indexOf("http") !== 0) {
                return self.signalComponentError(l10n.get("Need qualified URL"));
              }
              // We're going to do pattern detection on Github URLs to map them to the proxy
              var parser = document.createElement('a');
              parser.href = url;
              var host = parser.host;
              var pathParts = parser.pathname.split('/')
                                   .map(function(v) { return v.trim(); })
                                   .filter(function(v) { return v; });

              // XXXsecretrobotron: mywebmaker.org is makes.org staging server as of writing this.
              // NEEDS TO CHANGE if mywebmaker goes away.
              var makesMatch = host.match(/([^\.]+)\.(mywebmaker\.org|makes\.org)/);

              if (host === 'github.com') {
                url = this.mkGitHubURL(pathParts[0], pathParts[1]);
              }
              else if (host.indexOf(".github.io", this.length - ".github.io".length) !== -1) {
                // it's a GH pages page, yea!
                var ghUser = host.split('.')[0];
                var ghRepo = pathParts[0];
                url = this.mkGitHubURL(ghUser, ghRepo);
              }
              else if (makesMatch) {
                if (pathParts.length > 0) {
                  if (pathParts[pathParts.length - 1].search(/.+_$/) === -1) {
                    pathParts[pathParts.length - 1] = pathParts[pathParts.length - 1] + '_';
                  }
                  url = ['/', host].concat(pathParts).join('/');
                }
              }
            }
            this.getNameForComponentURL(url, function(err, result) {
              if (err) {
                return self.signalComponentError(err, result);
              }
              self.learnComponent(url, result)
            });
          }
          catch (e) {
            reporter.errorReport(e);
          }
        },
        addComponent: function() {
          if (!this.customcomponents) { return; }

          var self = this;
          // in a try/except block because called from an onclick handler,
          // so want to catch exceptions.
          var url = window.prompt(l10n.get("component url?"));
          if (! url) return;
          url = url.trim();
          self.addComponentByURL(url);
        },
        mkGitHubURL: function(repo, user) {
          // use the DOM to create the right URL.
          var parser = document.createElement('a');
          parser.href = document.URL;
          parser.pathname = "component/" + repo + '/' + user + "/component.html";
          return parser.href;
        },
        getNameForComponentURL: function(url, cb) {
          // We want to make sure that we can reach this URL, and that it's a component
          var self = this;
          // Let's load it!
          $.ajax(url, {
            data: {},
            type: 'get',
            success: function (data) {
              // we have a reachable URL, that's good.
              // Check to make sure that the file has a reasonable structure
              cb(null, self.getNameForComponent(url, data));
            },
            error: function (data, err) {
              // it may be because it's behind a CORS thing, in which case we will try to proxy through the server
              cb(l10n.get("getNameForComponentURL failed") + url, data);
          }});
        },
        getNameForComponent: function(url, data) {
          var doc = document.createDocumentFragment();
          doc.appendChild(document.createElement("body"));
          doc.querySelector("body").innerHTML = data;
          var componentElement = doc.querySelector("polymer-element");
          if (!componentElement) {
            return self.signalComponentError(l10n.get("Does not seem component"));
          }
          return componentElement.getAttribute('name');
        },
        learnComponent: function(url, name) {
          if (!this.customcomponents) { return; }

          // This function is to teach appmaker (client & server) about a new component URL
          var self = this;
          if (tray.isKnownComponent(name)) {
            return self.signalComponentError(l10n.get("We already know") + name)
          }
          this.storeComponentURL(url, name, function(err, result) {
            self.addComponentToUI(url, name, function(err, result) {
              if(err) {
                return self.signalComponentError(err);
              }
              reporter.notify(l10n.get("Successfully added component ") + name);
              analytics.event("Added Component", { label : name });
            });
          });
        },
        storeComponentURL: function(url, name, next) {
          if (!this.customcomponents) { return; }

          var self = this;
          $.ajax('/api/componentlinks', {
            data: {
              url: url,
              name: name
            },
            type: 'post',
            success: function (data) {
              // keep going
              next && next();
            },
            error: function (data) {
              // break off the process by not calling next()
              self.signalComponentError(l10n.get("error storing info about component: ") + JSON.stringify(data.responseJSON.error), data.responseJSON)
            }
          });
        },
        addComponentToUI: function(url, name, cb) {
          if (!this.customcomponents) {
            cb('Custom components are not available in this build');
            return;
          }

          var self = this;
          // Add to the menu
          var menuItem = this.addMenuItemForComponent(url, name);
          // add to polymer, the tray, etc.
          this.loadLink(name, url, function(err, linkElement) {
            if (err) {
              if(cb) cb(err.error)
              else self.signalComponentError(err.error);
              return;
            }
            menuItem.setBroken(false);
            tray.addComponentsFromRegistry();
            if(cb) cb(null, name);
          });
        },
        addMenuItemForComponent: function(url, name) {
          if (!this.customcomponents) { return; }

          var self = this;

          var component = document.createElement('li');
          component.setAttribute('data-link-name', name);
          component.classList.add('component');
          component.setBroken = function(b) {
            if(b) component.classList.add("broken");
            else component.classList.remove("broken");
          };
          // assume broken, unbreak if legal component.
          component.setBroken(true);

          var componentEntry = document.createElement('a');
          componentEntry.textContent = name;
          componentEntry.setAttribute('class', 'componentlink');

          var closeButton = document.createElement('a');
          closeButton.setAttribute('class', 'x');
          closeButton.addEventListener('click', function(event) {
            if (window.confirm(l10n.get("Are you sure you want to forget about the component at ") + url)) {
              self.forgetComponent(name, url);
              return;
            }
            event.stopPropagation();
          });

          var myComponents = this.shadowRoot.querySelector("#mycomponents");
          componentEntry.appendChild(closeButton);
          component.appendChild(componentEntry);
          myComponents.appendChild(component);

          return component;
        },
        attributeChangedCallback: function(attributeName) {
          if (attributeName == 'user') {
            this.refreshUserState();
          }
        },
        toggleMenu: function(e) {
          var parent;
          if(e.target.classList.contains("menu-button")){
            parent = e.target.parentNode;
          } else {
            parent = e.target.parentNode.parentNode;
          }

          var isOpen = false;
          if(parent.classList.contains("menu-open")){
            isOpen = true;
          }

          this.closeMenus();
          if(!isOpen){
            parent.classList.add("menu-open");
            document.addEventListener("click", this.closeMenus);
          }
        },
        closeMenus: function(){
          var userState = document.querySelector("user-state");
          var menus = userState.shadowRoot.querySelectorAll(".menu-wrapper");
          for(var j = 0; j < menus.length ; j++){
            menus[j].classList.remove("menu-open");
          }
          document.removeEventListener("click", userState.closeMenus);
        },
        refreshUserState: function() {
          var storedAppName = application.getStoredAppName() || "";
          if (!user.preventLoadedAppInsertion && storedAppName) {
            this.updateAppName(storedAppName || l10n.get("Unsaved App"));
          }

          // go to the server and find out what the user's apps are and then...
          // Build the list of apps
          // Update "current app" in apps menu
          this.refreshAppList(storedAppName);
          this.refreshComponentsList();
        },
        refreshAppList: function(storedAppName) {
          var self = this;

          if (user.state === "signedout") {
            return;
          }

          var myApps = this.shadowRoot.querySelector("#myapps");
          var noApps = this.shadowRoot.querySelector("#noApps");

          $.getJSON("/api/myapps", function(data) {
            myApps.innerHTML = "";

            data = data.sort(function(a,b){
              if(a.name.toLowerCase() > b.name.toLowerCase()){
                return 1;
              }
              if(a.name.toLowerCase() < b.name.toLowerCase()){
                return -1;
              }
              return 0;
            });

            try {
              var count = 0;
              $.each(data, function(key, val) {
                count++;
                var app = document.createElement('li');
                var link = document.createElement('a');
                link.id = key;
                link.classList.add('app');
                link.textContent = val.name;
                if(storedAppName === val.name){
                  link.classList.add('storedAppName');
                }
                link.classList.add('class', 'applink');
                link.addEventListener('click', function(){
                  application.loadAppByName(val.name);
                  self.editingmode = "saved";
                });
                app.appendChild(link);
                myApps.appendChild(app);
              });

              if(count == 0){
                noApps.classList.remove("hidden");
              } else {
                noApps.classList.add("hidden");
              }
            } catch (e) {
              reporter.errorReport(e);
            }
          });
        },
        forgetComponent: function(name, url) {
          var self = this;
          $.ajax('/api/componentlinks', {
            data: {
              url: url
            },
            type: 'delete',
            success: function (data) {
              // remove from tray, and user pulldown menu
              tray.forgetComponent(name);
              var userState = document.querySelector("user-state").shadowRoot;
              var li = userState.querySelector("[data-link-name='"+name+"']");
              li.parentNode.removeChild(li);
            },
            error: function (data, err) {
              self.signalComponentError(l10n("Forget failed") + data.url, err);
            }
          });
        },
        refreshComponentsList: function() {
          if(!this.customcomponents || user.state === "signedout") {
            return;
          }

          var self = this;
          var myComponents = this.shadowRoot.querySelector("#mycomponents");
          myComponents.innerHTML = "";
          $.getJSON("/api/componentlinks", function(data) {
            try {
              var count = 0;
              $.each(data, function(key, val) {
                count++;
                self.addComponentToUI(val.url, val.name);
              });
            } catch (e) {
              reporter.errorReport(e);
            }
          });
        },
        setAppURL: function(url) {
          var viewlink = this.$.viewlink;
          if(url) {
            viewlink.setAttribute("href", url);
            viewlink.classList.remove("hidden");
          }
          else {
            viewlink.setAttribute("href", '');
            viewlink.classList.add("hidden");
          }
        },
        collaborateClick: function () {
          TogetherJS(window);
        }
      });

      togetherjs_extension.init(user);
    }

   require(['designer/togetherjs', 'l10n', 'jquery', 'designer/application', 'designer/component-tray', 'designer/utils', 'reporter', 'analytics', 'persona', 'webmaker-auth-client'],
      function(togetherjs_extension, l10n, jquery, application, tray, utils, reporter, analytics, persona, WebmakerAuthClient) {
        init(togetherjs_extension, l10n, jquery, application, tray, utils, reporter, analytics, persona, WebmakerAuthClient);
      },
      function(err) {
        console.error('Failed to load a required module (analytics and/or persona and/or webmaker-auth-client)', err);
        require(['designer/togetherjs', 'l10n', 'jquery', 'designer/application', 'designer/component-tray', 'designer/utils', 'reporter'], init);
      }
    );

  })();
  </script>
</polymer-element>

<polymer-element name="data-manager" attributes="collection">
  <template>
    <style>
      :host {
        display: block;
        border: 1px solid #C5C5C5;
        padding: 10px;
      }
      :host input {
        font-size: 15px;
        width: 100%;
        border: solid 1px #C5C5C5;
        border-radius: 1px;
        color: #555;
        margin: 0px;
        outline: none;
        font-family: 'Source Sans Pro', arial;
        -moz-box-sizing: border-box;
        box-sizing: border-box;
        padding: 5px;
      }
      :host h3 {
        color: #555;
        margin-bottom: 2px;
        font-weight: normal;
        font-size: 15px;
      }
      :host .editable-attributes div {
        padding-bottom: 10px;
      }
      :host ul {
        list-style: none;
        margin: 0;
        padding: 0;
      }
      :host ul li {
        margin-top: 10px;
      }

      :host table {
        margin-top: 10px;
        width: 100%;
        border: 1px solid #c0c0c0;
      }

      :host .hidden {
        display: none;
      }

      :host #data-table .table-input {
        height: inherit;
        background: transparent;
        text-indent: 0;
      }

      :host #data-table .add-remove-column {
        text-align: center;
        cursor: pointer;
        background: #BBB;
      }

      :host #data-table .add-remove-column:hover {
        color: #212429;
        background: #CCC;
      }
    </style>
    <select value="{{currentCollectionIndex}}">
      <option value="-1">Choose a Collection</option>
      <template repeat="{{collection, index in collections}}">
        <option value="{{index}}">{{collection.collectionname}}</option>
      </template>
    </select>
    <button on-click="{{removeCollection}}" hidden?="{{ currentCollectionIndex == -1 }}">-</button>
    <button on-click="{{addCollection}}">+</button>
    <div hidden?="{{ currentCollectionIndex == -1 }}">
      <h3>Name</h3>
      <template repeat="{{collection, collectionIndex in collections}}">
        <div data-collection-name="{{collection.collectionname}}" data-index="{{collectionIndex}}" hidden?="{{currentCollectionIndex != collectionIndex}}">
          <input type="text" value="{{collection.collectionname}}" on-change="{{onCollectionNameChange}}">
          <h3>Keys</h3>
          <ul style="list-style: none;">
            <template repeat="{{item, fieldIndex in collection.fields}}">
              <li data-field-name="{{item.fieldname}}" data-index="{{fieldIndex}}" >
                <input data-index="{{fieldIndex}}" type="text" value="{{item.fieldname}}" on-change="{{onFieldNameChange}}">
                <select data-index="{{fieldIndex}}" value="{{item.kind}}" on-change="{{onItemTypeChange}}">
                  <option value="number">Number</option>
                  <option value="checkbox">Checkbox</option>
                  <option value="text">Text</option>
                  <option value="name">Name</option>
                  <option value="address">Address</option>
                  <option value="url">URL</option>
                  <option value="color">Color</option>
                  <option value="image">Image</option>
                </select>
                <button value="{{fieldIndex}}" on-click="{{removeKey}}">-</button>
              </li>
            </template>
          </ul>
          <button on-click="{{addKey}}">+</button>
          <table id="data-table">
            <tr>
              <template repeat="{{item in collection.fields}}">
                <td>{{item.fieldname}}</td>
              </template>
              <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
            </tr>
            <template repeat="{{row, dataIndex in collection.data}}">
              <tr>
                <template repeat="{{item, fieldIndex in collection.fields}}">
                  <template if="{{item.kind == 'checkbox'}}">
                    <td><input on-change="{{updateDataRow}}" data-index="{{dataIndex}}" class="table-input" type="{{item.kind}}" checked="{{row[item.fieldname]}}"></td>
                  </template>
                  <template if="{{item.kind != 'checkbox'}}">
                    <td><input on-change="{{updateDataRow}}" data-index="{{dataIndex}}" class="table-input" type="{{item.kind}}" value="{{row[item.fieldname]}}"></td>
                  </template>
                </template>
                <td data-index="{{dataIndex}}" on-click="{{removeDataRow}}" class="add-remove-column">-</td>
              </tr>
            </template>
            <tr>
              <template repeat="{{item, fieldIndex in collection.fields}}">
                <td><input data-key="{{fieldIndex}}" class="table-input" type="{{item.kind}}" value=""></td>
              </template>
              <td on-click="{{addDataRow}}" class="add-remove-column">+</td>
            </tr>
          </table>
        </div>
      </template>
    </div>
  </template>
  <script>
    Polymer('data-manager', {
      currentCollectionIndex: -1,
      createFieldManager: function(field) {
        var fieldName = field.getAttribute("fieldname");
        return {
          fieldname: fieldName,
          oldName: fieldName,
          kind: field.kind
        };
      },
      createCollectionManager: function(collection) {
        var collectionName = collection.getAttribute("collectionname");
        return {
          collectionname: collectionName,
          oldName: collectionName,
          fields: [],
          data: collection.data.slice(0)
        };
      },
      ready: function () {
        var self = this;
        this.collections = [];
        function onFieldChange(e) {
          var detail = e.detail;
          var collectionName = this.getAttribute("collectionname");
          var collectionSelector = '*[data-collection-name="'+ collectionName + '"]';
          var collectionElement = self.shadowRoot.querySelector(collectionSelector);
          if (!collectionElement) {
            return;
          }
          var collectionIndex = collectionElement.getAttribute("data-index");
          if (detail.added) {
            var obj = self.createFieldManager(detail.added);
            self.collections[collectionIndex].fields.push(obj);
            detail.added.addEventListener("propertychange", onFieldPropertyChange);
          } else if (detail.removed) {
            var fieldName = detail.removed.getAttribute("fieldname");
            var fieldSelector = '*[data-field-name="'+ fieldName + '"]';
            var fieldElement = self.shadowRoot.querySelector(fieldSelector);
            if (!fieldElement) {
              return;
            }
            var fieldIndex = fieldElement.getAttribute("data-index");
            self.collections[collectionIndex].fields.splice(fieldIndex, 1);
            detail.removed.removeEventListener("propertychange", onFieldPropertyChange);
          }
        }
        function onItemChange(e) {
          var detail = e.detail;
          var collectionName = this.getAttribute("collectionname");
          var collectionSelector = '*[data-collection-name="'+ collectionName + '"]';
          var collectionElement = self.shadowRoot.querySelector(collectionSelector);
          if (!collectionElement) {
            return;
          }
          var collectionIndex = collectionElement.getAttribute("data-index");
          if (detail.removed) {
            self.collections[collectionIndex].data.splice(detail.index, 1);
          }
          if (detail.added) {
            self.collections[collectionIndex].data.splice(detail.index, 0, detail.added);
          }
        }
        function onFieldPropertyChange(e) {
          var detail = e.detail;
          if (detail.changed) {
            this.async(function() {
              var collectionName = this.getCollectionName();
              var collectionSelector = '*[data-collection-name="'+ collectionName + '"]';
              var collectionElement = self.shadowRoot.querySelector(collectionSelector);
              if (!collectionElement) {
                return;
              }
              var collectionIndex = collectionElement.getAttribute("data-index");
              // name changes move around references so we handle this a little differently.
              if (detail.changed === "fieldname") {
                var oldName = detail.removed;
                var fieldSelector = '*[data-field-name="'+ oldName + '"]';
                var fieldElement = self.shadowRoot.querySelector(fieldSelector);
                if (!fieldElement) {
                  return;
                }
                var fieldIndex = fieldElement.getAttribute("data-index");
                self.collections[collectionIndex].fields[fieldIndex].oldName = this[detail.changed];
                self.collections[collectionIndex].fields[fieldIndex].fieldname = this[detail.changed];
              } else {
                var fieldName = this.getAttribute("fieldname");
                var fieldSelector = '*[data-field-name="'+ fieldName + '"]';
                var fieldElement = self.shadowRoot.querySelector(fieldSelector);
                if (!fieldElement) {
                  return;
                }
                var fieldIndex = fieldElement.getAttribute("data-index");
                self.collections[collectionIndex].fields[fieldIndex][detail.changed] = this[detail.changed];
              }
            });
          }
        }
        function onCollectionPropertyChange(e) {
          var detail = e.detail;
          if (detail.changed && detail.changed === "collectionname") {
            this.async(function() {
              var oldName = detail.removed;
              var collectionSelector = '*[data-collection-name="'+ oldName + '"]';
              var collectionElement = self.shadowRoot.querySelector(collectionSelector);
              if (!collectionElement) {
                return;
              }
              var collectionIndex = collectionElement.getAttribute("data-index");
              self.collections[collectionIndex].oldName = this[detail.changed];
              self.collections[collectionIndex].collectionname = this[detail.changed];
            });
          }
        }
        function onCollectionChange(e) {
          var detail = e.detail;
          if (detail.added) {
            var obj = self.createCollectionManager(detail.added);
            self.collections.push(obj);
            detail.added.addEventListener("itemchange", onItemChange);
            detail.added.addEventListener("fieldchange", onFieldChange);
            detail.added.addEventListener("propertychange", onCollectionPropertyChange);
          }
          if (detail.removed) {
            var collectionName = detail.removed.getAttribute("collectionname");
            var collectionSelector = '*[data-collection-name="'+ collectionName + '"]';
            var collectionElement = self.shadowRoot.querySelector(collectionSelector);
            if (!collectionElement) {
              return;
            }
            var collectionIndex = parseInt(collectionElement.getAttribute("data-index"), 10);
            self.collections.splice(collectionIndex, 1);
            if (collectionIndex === self.currentCollectionIndex) {
              self.async(function() {
                this.currentCollectionIndex = -1;
              });
            }
            detail.removed.removeEventListener("itemchange", onItemChange);
            detail.removed.removeEventListener("fieldchange", onFieldChange);
            detail.removed.removeEventListener("propertychange", onCollectionPropertyChange);
          }
        }

        self.collectionsElement = document.querySelector("ceci-collections");
        var collections = self.collectionsElement.getCollections();
        if (collections.length) {
          collections.forEach(function(collection) {
            var collectionObj = self.createCollectionManager(collection);
            var fields = collection.getFields();
            self.collections.push(collectionObj);
            fields.forEach(function(field) {
              var fieldObj = self.createFieldManager(field);
              collectionObj.fields.push(fieldObj);
              field.addEventListener("propertychange", onFieldPropertyChange);
            });
            collection.addEventListener("fieldchange", onFieldChange);
            collection.addEventListener("itemchange", onItemChange);
            collection.addEventListener("propertychange", onCollectionPropertyChange);
          });
        }
        self.collectionsElement.addEventListener("collectionchange", onCollectionChange);
      },
      addCollection: function () {
        this.collectionsElement.addCollection("New Collection " + (this.collections.length + 1));
        this.async(function () {
          this.currentCollectionIndex = this.collections.length - 1;
        });
      },
      removeCollection: function () {
        this.collectionsElement.removeCollection(this.collections[this.currentCollectionIndex].collectionname);
        this.async(function () {
          this.currentCollectionIndex = -1;
        });
      },
      addKey: function () {
        var collection = this.collections[this.currentCollectionIndex];
        this.collectionsElement.getCollection(collection.collectionname).addField("New Field " + (collection.fields.length + 1));
      },
      removeKey: function (event, detail, sender) {
        var collection = this.collections[this.currentCollectionIndex];
        var field = collection.fields[parseInt(sender.value, 10)];
        this.collectionsElement.getCollection(collection.collectionname).removeField(field.fieldname);
      },
      addDataRow: function (event, detail, sender) {
        var newRow = {};
        var dummyRow = sender.parentNode;
        this.collections[this.currentCollectionIndex].fields.forEach(function (item, index) {
          var inputElement = dummyRow.querySelector('*[data-key="'+ index + '"]');
          if (item.kind === 'checkbox') {
            newRow[item.fieldname] = newRow[item.fieldname] || inputElement.checked;
            inputElement.checked = '';
          } else {
            newRow[item.fieldname] = newRow[item.fieldname] || inputElement.value;
            inputElement.value = '';
          }
        });
        var collection = this.collections[this.currentCollectionIndex];
        this.collectionsElement.getCollection(collection.collectionname).addItem(newRow);
      },
      removeDataRow: function (event, detail, sender) {
        var collection = this.collections[this.currentCollectionIndex];
        this.collectionsElement.getCollection(collection.collectionname).removeItem(parseInt(sender.getAttribute('data-index'), 10));
      },
      updateDataRow: function (event, detail, sender) {
        var collectionName = this.collections[this.currentCollectionIndex].collectionname;
        var collection = this.collectionsElement.getCollection(collectionName)
        var index = parseInt(sender.getAttribute('data-index'), 10);
        var item = collection.data[index]
        collection.updateItem(index, item);
      },
      onItemTypeChange: function(event, detail, sender) {
        var collection = this.collections[this.currentCollectionIndex];
        var field = collection.fields[parseInt(sender.getAttribute('data-index'), 10)];
        this.collectionsElement.getField(collection.collectionname, field.fieldname).kind = sender.value;
      },
      onCollectionNameChange: function(event, detail, sender) {
        var collection = this.collections[this.currentCollectionIndex];
        var oldName = collection.oldName;
        var oldCollection = this.collectionsElement.getCollection(oldName);
        // This likely means its name was already changed by another data manager.
        if (!oldCollection) {
          return;
        }
        collection.oldName = collection.collectionname;
        oldCollection.setAttribute("collectionname", sender.value);
      },
      onFieldNameChange: function(event, detail, sender) {
        var collection = this.collections[this.currentCollectionIndex];
        var field = collection.fields[parseInt(sender.getAttribute('data-index'), 10)];
        var oldName = field.oldName;
        var oldField = this.collectionsElement.getField(collection.collectionname, oldName);
        // This likely means its name was already changed by another data manager.
        if (!oldField) {
          return;
        }
        field.oldName = field.fieldname;
        oldField.setAttribute("fieldname", sender.value);
      },
      collectionChanged: function() {
        var collection = this.getAttribute("collection");
        var found = false;
        var newIndex;
        if (!collection) {
          found = true;
          newIndex = -1;
        } else {
          for (var i = 0; i < this.collections.length; i++) {
            if (this.collections[i].collectionname === collection) {
              newIndex = i;
              found = true;
              break;
            }
          }
        }
        if (found) {
          this.async(function () {
            this.currentCollectionIndex = newIndex;
          });
        } else {
          this.collectionsElement.addCollection(collection);
          this.async(function () {
            this.currentCollectionIndex = this.collections.length - 1;
          });
        }
        this.fire("collectionchange", this.getAttribute("collection"));
      },
      currentCollectionIndexChanged: function() {
        var collection = this.collections[this.currentCollectionIndex];
        var collectionName = "";
        if (collection) {
          collectionName = this.collections[this.currentCollectionIndex].collectionname;
        }
        this.setAttribute("collection", collectionName);
      }
    });
  </script>
</polymer-element>

<polymer-element name="project-settings">
  <template>
    <style>
      :host {
        font-weight: 300;
        font-size: 14px;
        color: #666;
      }
      :host input,
      :host textarea,
      :host label {
        font-size: inherit;
        font-weight: inherit;
        color: inherit;
        font-family: inherit;
      }

      :host input,
      :host textarea {
        width: 100%;
        border: solid 1px #C5C5C5;
        border-radius: 1px;
        outline: none;
        padding: 5px;
        margin: 0;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
      }
      :host textarea {
        height: 100px;
        box-sizing: border-box;
        resize: vertical;
      }
      :host label {
        margin-bottom: 2px;
        display: block;
      }
      :host .editable-attributes div {
        margin-bottom: 10px;
      }
    </style>
    <div class="editable-attributes">
      <div>
        <label>Title</label>
        <input type="text" on-change="{{onAppNameChange}}" on-focus="{{onAppNameFocus}}" value="{{app.name}}"></label>
      </div>
      <div>
        <label>Description</label>
        <textarea on-change="{{onAppDescriptionChange}}" class="project-settings-description" placeholder="My app..." maxlength="200" value={{app.appdescription}}></textarea>
      </div>
      <div>
        <label>Tags</label>
        <input on-change="{{onAppTagsChange}}" placeholder="Space seperated list of tags" type="text" value="{{app.apptags}}"></label>
      </div>
      <div>
        <label>App Data</label>
        <div class="data-manager"></div>
      </div>
    </div>
  </template>
  <script>
    Polymer('project-settings', {
      ready: function() {
        var that = this;
        function onCeciAppDOMReady () {
          that.app = document.querySelector("ceci-app");
          // For now we need to ensure data manager isn't added until after potential data is ready.
          var dataManager = document.createElement("data-manager");
          var dataManagerContainer = that.shadowRoot.querySelector(".data-manager");
          // Clear out old managers if this page loaded a new app
          // from the app loading menu or new app being clicked.
          dataManagerContainer.innerHTML = "";
          dataManagerContainer.appendChild(dataManager);
        }
        window.addEventListener("CeciAppDOMReady", onCeciAppDOMReady);
      },
      onAppNameChange: function(event, detail, sender) {
        var userState = document.querySelector('user-state');
        if (userState.editingmode !== "saved") {
          userState.saveAppAs(sender.value);
        } else {
          userState.renameApp(this.name, sender.value);
        }
      },
      onAppDescriptionChange: function(event, detail, sender) {
        this.app.setAttribute("appdescription", sender.value);
      },
      onAppTagsChange: function(event, detail, sender) {
        this.app.setAttribute("apptags", sender.value);
      },
      onAppNameFocus: function(event, detail, sender) {
        this.name = sender.value;
      }
    });
  </script>
</polymer-element>
